{"file_contents":{"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nfrom utils.market_data import get_nifty_data, get_top_gainers_losers\nfrom utils.fundamentals import get_fundamental_data\nfrom utils.ai_analysis import get_market_sentiment_analysis\nfrom utils.news_scraper import get_financial_news\nimport threading\nimport time\n\n# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# üîß ADVANCED TECHNICAL INDICATORS\n# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\ndef supertrend(df, period=10, multiplier=3):\n    \"\"\"Calculate Supertrend indicator\"\"\"\n    hl2 = (df['High'] + df['Low']) / 2\n    atr = df['High'].rolling(window=period).max() - df['Low'].rolling(window=period).min()\n    atr = atr.rolling(window=period).mean()\n\n    upper_band = hl2 + multiplier * atr\n    lower_band = hl2 - multiplier * atr\n\n    supertrend_values = []\n    trend_direction = []\n    in_uptrend = True\n\n    for i in range(len(df)):\n        if i == 0:\n            supertrend_values.append(hl2.iloc[i])\n            trend_direction.append(1)\n            continue\n\n        if df['Close'].iloc[i] > upper_band.iloc[i-1]:\n            in_uptrend = True\n        elif df['Close'].iloc[i] < lower_band.iloc[i-1]:\n            in_uptrend = False\n\n        if in_uptrend:\n            supertrend_values.append(lower_band.iloc[i])\n            trend_direction.append(1)\n        else:\n            supertrend_values.append(upper_band.iloc[i])\n            trend_direction.append(-1)\n\n    return pd.Series(supertrend_values, index=df.index), pd.Series(trend_direction, index=df.index)\n\ndef bollinger_bands(close, window=20, num_std=2):\n    \"\"\"Calculate Bollinger Bands\"\"\"\n    sma = close.rolling(window=window).mean()\n    std = close.rolling(window=window).std()\n    upper_band = sma + (num_std * std)\n    lower_band = sma - (num_std * std)\n    return sma, upper_band, lower_band\n\ndef rsi(close, window=14):\n    \"\"\"Calculate RSI\"\"\"\n    delta = close.diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n\n    avg_gain = gain.rolling(window=window).mean()\n    avg_loss = loss.rolling(window=window).mean()\n\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    return rsi\n\ndef fisher_transform(high, low, period=9):\n    \"\"\"Calculate Fisher Transform\"\"\"\n    hl2 = (high + low) / 2\n\n    # Normalize the values\n    highest = hl2.rolling(window=period).max()\n    lowest = hl2.rolling(window=period).min()\n\n    normalized = 2 * ((hl2 - lowest) / (highest - lowest)) - 1\n    normalized = normalized.fillna(0).clip(-0.999, 0.999)\n\n    fisher = pd.Series(index=high.index, dtype=float)\n    fisher_signal = pd.Series(index=high.index, dtype=float)\n\n    for i in range(len(normalized)):\n        if i == 0:\n            fisher.iloc[i] = 0\n            fisher_signal.iloc[i] = 0\n        else:\n            fisher_value = 0.5 * np.log((1 + normalized.iloc[i]) / (1 - normalized.iloc[i]))\n            fisher.iloc[i] = 0.33 * fisher_value + 0.67 * fisher.iloc[i-1]\n            fisher_signal.iloc[i] = fisher.iloc[i-1]\n\n    return fisher, fisher_signal\n\ndef macd(close, fast=12, slow=26, signal=9):\n    \"\"\"Calculate MACD\"\"\"\n    exp1 = close.ewm(span=fast).mean()\n    exp2 = close.ewm(span=slow).mean()\n    macd_line = exp1 - exp2\n    signal_line = macd_line.ewm(span=signal).mean()\n    histogram = macd_line - signal_line\n    return macd_line, signal_line, histogram\n\ndef stochastic(high, low, close, k_period=14, d_period=3):\n    \"\"\"Calculate Stochastic Oscillator\"\"\"\n    lowest_low = low.rolling(window=k_period).min()\n    highest_high = high.rolling(window=k_period).max()\n\n    k_percent = 100 * ((close - lowest_low) / (highest_high - lowest_low))\n    d_percent = k_percent.rolling(window=d_period).mean()\n\n    return k_percent, d_percent\n\ndef volume_profile(close, volume, bins=20):\n    \"\"\"Calculate Volume Profile\"\"\"\n    price_min = close.min()\n    price_max = close.max()\n\n    # Create price levels\n    price_levels = np.linspace(price_min, price_max, bins)\n    volume_at_price = []\n\n    for i in range(len(price_levels) - 1):\n        level_low = price_levels[i]\n        level_high = price_levels[i + 1]\n\n        mask = (close >= level_low) & (close < level_high)\n        level_volume = volume[mask].sum()\n\n        volume_at_price.append({\n            'price': (level_low + level_high) / 2,\n            'volume': level_volume\n        })\n\n    return pd.DataFrame(volume_at_price)\n\n# Configure page\nst.set_page_config(page_title=\"Dravyum\",\n                   page_icon=\"‚ö°\",\n                   layout=\"wide\",\n                   initial_sidebar_state=\"expanded\")\n\n# Custom CSS for DRAVYUM - Sleek Black & White Theme\nst.markdown(\"\"\"\n<style>\n    /* DRAVYUM Black & White Luxury Theme */\n    .stApp {\n        background-color: #000000;\n        color: #FFFFFF;\n    }\n\n    /* Header styling */\n    .main-header {\n        background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #000000 100%);\n        padding: 2rem;\n        border-radius: 15px;\n        color: #FFFFFF;\n        text-align: center;\n        margin-bottom: 2rem;\n        box-shadow: 0 8px 32px rgba(255,255,255,0.1);\n        border: 1px solid #333333;\n    }\n\n    /* Metric cards */\n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #1a1a1a, #000000);\n        border: 1px solid #333333;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(255,255,255,0.05);\n        color: #FFFFFF;\n    }\n\n    /* Sidebar styling */\n    .css-1d391kg, section[data-testid=\"stSidebar\"] {\n        background-color: #000000 !important;\n        color: #FFFFFF !important;\n        border-right: 5px solid #333333;\n    }\n\n    /* Tabs styling */\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 30px;\n        background-color: #1a1a1a;\n        border-radius: 15px;\n        padding: 10px;\n        border: 1px solid #333333;\n    }\n\n    .stTabs [data-baseweb=\"tab\"] {\n        background-color: #000000;\n        color: #FFFFFF;\n        border-radius: 8px;\n        font-weight: bold;\n        border: 2px solid #333333;\n    }\n\n    .stTabs [data-baseweb=\"tab\"][aria-selected=\"true\"] {\n        background-color: #FFFFFF;\n        color: #000000;\n        border: 2px solid #FFFFFF;\n    }\n\n    /* Button styling */\n    .stButton > button {\n        background: linear-gradient(145deg, #1a1a1a, #000000);\n        color: #FFFFFF;\n        border: 1px solid #333333;\n        border-radius: 10px;\n        font-weight: bold;\n        transition: all 0.3s ease;\n    }\n\n    .stButton > button:hover {\n        background: linear-gradient(145deg, #FFFFFF, #f0f0f0);\n        color: #000000;\n        transform: translateY(-2px);\n        box-shadow: 0 6px 20px rgba(255,255,255,0.2);\n        border: 1px solid #FFFFFF;\n    }\n\n    /* Text styling */\n    h1, h2, h3, h4, h5, h6, p, span, div {\n        color: #FFFFFF !important;\n        font-weight: normal;\n    }\n\n    /* DataFrame styling */\n    .dataframe {\n        background-color: #1a1a1a !important;\n        color: #FFFFFF !important;\n        border: 1px solid #333333;\n    }\n\n    /* News card styling */\n    .news-card {\n        background: linear-gradient(145deg, #1a1a1a, #000000);\n        border: 1px solid #333333;\n        border-radius: 10px;\n        padding: 3rem;\n        margin: 2rem 0;\n        box-shadow: 0 4px 15px rgba(255,255,255,0.05);\n    }\n\n    /* Input styling */\n    .stTextInput > div > div > input {\n        background-color: #1a1a1a;\n        color: #FFFFFF;\n        border: 1px solid #333333;\n    }\n\n    /* Plotly chart background */\n    .js-plotly-plot {\n        background-color: #000000 !important;\n    }\n\n    /* Chart container styling */\n    .chart-container {\n        background: linear-gradient(145deg, #1a1a1a, #000000);\n        border: 1px solid #333333;\n        border-radius: 15px;\n        padding: 1rem;\n        margin: 1rem 0;\n        box-shadow: 0 4px 20px rgba(255,255,255,0.05);\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\ndef main():\n    # Luxury header with brand name\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 3rem; font-weight: bold; color: #FFFFFF;\">‚ö° Dravyum</h1>\n        <p style=\"margin: 0.5rem 0 0 0; font-size: 1.2rem; opacity: 0.9; color: #FFFFFF;\">Master AI Trading Intelligence for Indian Markets</p>\n        <p style=\"margin: 0.3rem 0 0 0; font-size: 1rem; opacity: 0.7;\">NSE ‚Ä¢ BSE ‚Ä¢ Advanced Analytics ‚Ä¢ Free & Open Source</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Sidebar for quick market overview\n    with st.sidebar:\n        st.header(\"üìä Quick Market Overview\")\n        try:\n            # Get NIFTY 50 data\n            nifty_data = get_nifty_data()\n            if not nifty_data.empty:\n                current_price = nifty_data['Close'].iloc[-1]\n                prev_price = nifty_data['Close'].iloc[-2]\n                change = current_price - prev_price\n                change_pct = (change / prev_price) * 100\n\n                col1, col2 = st.columns(2)\n                with col1:\n                    st.metric(label=\"NIFTY 50\",\n                              value=f\"‚Çπ{current_price:,.2f}\",\n                              delta=f\"{change:+.2f} ({change_pct:+.2f}%)\")\n\n                # Mini chart\n                fig = go.Figure()\n                fig.add_trace(\n                    go.Scatter(x=nifty_data.index[-30:],\n                               y=nifty_data['Close'].iloc[-30:],\n                               mode='lines',\n                               line=dict(color='#FF6B6B', width=2),\n                               name='NIFTY 50'))\n\n                fig.update_layout(height=200,\n                                  margin=dict(l=0, r=0, t=0, b=0),\n                                  showlegend=False,\n                                  xaxis=dict(showgrid=False,\n                                             showticklabels=False),\n                                  yaxis=dict(showgrid=False,\n                                             showticklabels=False),\n                                  plot_bgcolor='rgba(0,0,0,0)',\n                                  paper_bgcolor='rgba(0,0,0,0)')\n\n                st.plotly_chart(fig, use_container_width=True)\n            else:\n                st.error(\"Unable to fetch NIFTY data\")\n        except Exception as e:\n            st.error(f\"Error loading market data: {str(e)}\")\n\n        # Latest Financial News Section\n        st.markdown(\"---\")\n        st.header(\"üì∞ Latest Market News\")\n\n        # Load news\n        if 'latest_news' not in st.session_state:\n            with st.spinner(\"Loading news...\"):\n                st.session_state.latest_news = get_financial_news()\n\n        news_articles = st.session_state.latest_news[:5]  # Show top 5 in sidebar\n\n        for article in news_articles:\n            st.markdown(f\"\"\"\n            <div style='padding: 0.5rem; margin: 0.3rem 0; background: linear-gradient(145deg, #C6AC8E, #EAEOD5); \n                 border-radius: 8px; border-left: 3px solid #000000;'>\n                <p style='margin: 0; font-size: 0.8rem; font-weight: bold; color: #000000;'>{article['title'][:60]}...</p>\n                <p style='margin: 0; font-size: 0.7rem; opacity: 0.7; color: #000000;'>{article['source']} ‚Ä¢ {article['timestamp']}</p>\n            </div>\n            \"\"\",\n                        unsafe_allow_html=True)\n\n        # Quick actions\n        st.markdown(\"---\")\n        st.header(\"‚ö° Quick Actions\")\n\n        col_news, col_data = st.columns(2)\n        with col_news:\n            if st.button(\"üì∞ Refresh News\", use_container_width=True):\n                with st.spinner(\"Loading news...\"):\n                    st.session_state.latest_news = get_financial_news()\n                    st.rerun()\n\n        with col_data:\n            if st.button(\"üîÑ Refresh Data\", use_container_width=True):\n                st.rerun()\n\n        if st.button(\"üìß Send Daily Report\", use_container_width=True):\n            st.success(\"Report generation initiated!\")\n\n    # Main content area - Updated with 5 tabs\n    tab1, tab2, tab3, tab4, tab5 = st.tabs([\n        \"üìà Market Overview\", \"üî• Top Movers\", \"üìä Breakout Analysis\", \n        \"üìâ Advanced Charts\", \"ü§ñ AI Insights\"\n    ])\n\n    with tab1:\n        st.header(\"Market Overview\")\n\n        # Market News Section (Top of Overview)\n        st.subheader(\"üì∞ Latest Financial News\")\n        try:\n            if 'latest_news' not in st.session_state:\n                with st.spinner(\"Loading latest market news...\"):\n                    st.session_state.latest_news = get_financial_news()\n\n            news_articles = st.session_state.latest_news[:8]  # Show top 8 in main area\n\n            # Display news in 2 columns\n            news_col1, news_col2 = st.columns(2)\n            for i, article in enumerate(news_articles):\n                with news_col1 if i % 2 == 0 else news_col2:\n                    st.markdown(f\"\"\"\n                    <div style='padding: 2rem; margin: 2rem 0; background: linear-gradient(145deg, #C6AC8E, #EAEOD5); \n                         border-radius: 10px; border: 2px solid #000000; box-shadow: 0 4px 8px rgba(0,0,0,0.1);'>\n                        <h4 style='margin: 0; font-size: 1rem; font-weight: bold; color: #000000; line-height: 1.2;'>{article['title']}</h4>\n                        <p style='margin: 0.3rem 0 0 0; font-size: 0.75rem; opacity: 0.8; color: #000000;'>\n                            üì∫ {article['source']} ‚Ä¢ ‚è∞ {article['timestamp']}\n                        </p>\n                        {f\"<p style='margin: 0.3rem 0 0 0; font-size: 0.7rem;'><a href='{article['url']}' target='_blank' style='color: #000000; text-decoration: none;'>üîó Read Full Article</a></p>\" if article['url'] != '#' else ''}\n                    </div>\n                    \"\"\",\n                                unsafe_allow_html=True)\n        except Exception as e:\n            st.error(f\"Error loading news: {str(e)}\")\n            st.info(\"News service temporarily unavailable\")\n\n        st.markdown(\"---\")\n\n        # Market Indices Section\n        st.subheader(\"üìä Market Indices\")\n        col1, col2, col3, col4 = st.columns(4)\n\n        # Market indices\n        indices = [\"^NSEI\", \"^BSESN\", \"^NSEBANK\"]\n        index_names = [\"NIFTY 50\", \"SENSEX\", \"BANK NIFTY\"]\n\n        for i, (index, name) in enumerate(zip(indices, index_names)):\n            try:\n                ticker = yf.Ticker(index)\n                hist = ticker.history(period=\"2d\")\n                if not hist.empty:\n                    current = hist['Close'].iloc[-1]\n                    prev = hist['Close'].iloc[-2]\n                    change = current - prev\n                    change_pct = (change / prev) * 100\n\n                    with [col1, col2, col3][i]:\n                        st.metric(label=name,\n                                  value=f\"‚Çπ{current:,.2f}\",\n                                  delta=f\"{change:+.2f} ({change_pct:+.2f}%)\")\n            except Exception as e:\n                with [col1, col2, col3][i]:\n                    st.error(f\"Error loading {name}\")\n\n        # Market sentiment gauge\n        with col4:\n            try:\n                sentiment_score = 0.65  # This would come from AI analysis\n                st.metric(label=\"Market Sentiment\",\n                          value=\"Bullish\" if sentiment_score > 0.6 else\n                          \"Bearish\" if sentiment_score < 0.4 else \"Neutral\",\n                          delta=f\"Score: {sentiment_score:.2f}\")\n            except:\n                st.error(\"Sentiment unavailable\")\n\n    with tab2:\n        st.header(\"Top Gainers & Losers\")\n        try:\n            gainers, losers = get_top_gainers_losers()\n\n            col1, col2 = st.columns(2)\n            with col1:\n                st.subheader(\"üü¢ Top Gainers\")\n                if not gainers.empty:\n                    st.dataframe(\n                        gainers[['Symbol', 'LTP', 'Change',\n                                 '% Change']].head(10),\n                        use_container_width=True,\n                        hide_index=True)\n                else:\n                    st.info(\"No gainers data available\")\n\n            with col2:\n                st.subheader(\"üî¥ Top Losers\")\n                if not losers.empty:\n                    st.dataframe(\n                        losers[['Symbol', 'LTP', 'Change',\n                                '% Change']].head(10),\n                        use_container_width=True,\n                        hide_index=True)\n                else:\n                    st.info(\"No losers data available\")\n        except Exception as e:\n            st.error(f\"Error loading top movers: {str(e)}\")\n\n    with tab3:\n        st.header(\"NIFTY Breakout Analysis\")\n        st.markdown(\"Stocks breaking out above 6-8 day trading range\")\n        try:\n            # Sample breakout analysis - in production this would analyze all NIFTY stocks\n            breakout_data = {\n                'Symbol': ['RELIANCE', 'TCS', 'INFY', 'HDFC', 'ICICI'],\n                'Current Price': [2450, 3890, 1650, 1580, 950],\n                'Breakout Level': [2420, 3850, 1620, 1550, 930],\n                'Volume Spike': [2.3, 1.8, 2.1, 1.5, 2.0],\n                'Days in Range': [7, 6, 8, 7, 6]\n            }\n\n            df_breakout = pd.DataFrame(breakout_data)\n\n            # Histogram of breakout stocks\n            fig = px.histogram(\n                df_breakout,\n                x='Days in Range',\n                title=\"Distribution of Breakout Stocks by Days in Range\",\n                nbins=5,\n                color_discrete_sequence=['#FF6B6B'])\n\n            fig.update_layout(height=400)\n            st.plotly_chart(fig, use_container_width=True)\n\n            # Breakout stocks table\n            st.subheader(\"Current Breakout Stocks\")\n            st.dataframe(df_breakout,\n                         use_container_width=True,\n                         hide_index=True)\n        except Exception as e:\n            st.error(f\"Error in breakout analysis: {str(e)}\")\n\n    # ‚îÄ‚îÄ NEW TAB 4: ADVANCED CHARTS ‚îÄ‚îÄ\n    with tab4:\n        st.header(\"üìâ Advanced Interactive Charts\")\n        st.markdown(\"Professional charting with advanced technical indicators\")\n\n        # Stock selection and controls\n        col1, col2, col3 = st.columns([2, 1, 1])\n        with col1:\n            symbol_input = st.text_input(\"Enter NSE Symbol\", value=\"RELIANCE\", \n                                       placeholder=\"e.g., RELIANCE, TCS, INFY\")\n            symbol = symbol_input.upper().strip()\n\n        with col2:\n            period = st.selectbox(\"Timeframe\", \n                                [\"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\"], \n                                index=2)\n\n        with col3:\n            st.markdown(\"<br>\", unsafe_allow_html=True)  # Space for alignment\n            load_chart = st.button(\"üìä Load Chart\", use_container_width=True)\n\n        # Indicator controls\n        st.markdown(\"### üéõÔ∏è Technical Indicators\")\n        col1, col2, col3, col4 = st.columns(4)\n\n        with col1:\n            show_supertrend = st.checkbox(\"üî• Supertrend\", value=True)\n            show_bb = st.checkbox(\"üìä Bollinger Bands\", value=True)\n\n        with col2:\n            show_sma = st.checkbox(\"üìà SMA 20/50\", value=True)\n            show_rsi = st.checkbox(\"‚ö° RSI\", value=True)\n\n        with col3:\n            show_macd = st.checkbox(\"üåä MACD\", value=False)\n            show_fisher = st.checkbox(\"üêü Fisher Transform\", value=False)\n\n        with col4:\n            show_stoch = st.checkbox(\"üìâ Stochastic\", value=False)\n            show_volume_profile = st.checkbox(\"üìä Volume Profile\", value=False)\n\n        if load_chart or symbol:\n            try:\n                with st.spinner(f\"Loading chart data for {symbol}...\"):\n                    # Fetch data\n                    ticker_symbol = f\"{symbol}.NS\"\n                    data = yf.download(ticker_symbol, period=period, interval=\"1d\")\n\n                    if data.empty:\n                        st.error(f\"‚ùå No data found for {symbol}. Please check the symbol.\")\n                    else:\n                        # Calculate all indicators\n                        data['SMA_20'] = data['Close'].rolling(20).mean()\n                        data['SMA_50'] = data['Close'].rolling(50).mean()\n\n                        bb_middle, bb_upper, bb_lower = bollinger_bands(data['Close'])\n                        data['BB_Middle'] = bb_middle\n                        data['BB_Upper'] = bb_upper\n                        data['BB_Lower'] = bb_lower\n\n                        data['RSI'] = rsi(data['Close'])\n\n                        supertrend_line, supertrend_direction = supertrend(data)\n                        data['Supertrend'] = supertrend_line\n                        data['ST_Direction'] = supertrend_direction\n\n                        fisher, fisher_signal = fisher_transform(data['High'], data['Low'])\n                        data['Fisher'] = fisher\n                        data['Fisher_Signal'] = fisher_signal\n\n                        macd_line, macd_signal, macd_histogram = macd(data['Close'])\n                        data['MACD'] = macd_line\n                        data['MACD_Signal'] = macd_signal\n                        data['MACD_Histogram'] = macd_histogram\n\n                        stoch_k, stoch_d = stochastic(data['High'], data['Low'], data['Close'])\n                        data['Stoch_K'] = stoch_k\n                        data['Stoch_D'] = stoch_d\n\n                        # Get company info\n                        info = yf.Ticker(ticker_symbol).info\n                        company_name = info.get('longName', symbol)\n\n                        # Stock info header\n                        current_price = data['Close'].iloc[-1]\n                        prev_price = data['Close'].iloc[-2]\n                        change = current_price - prev_price\n                        change_pct = (change / prev_price) * 100\n\n                        st.markdown(f\"\"\"\n                        <div class=\"chart-container\">\n                            <h2>üìà {company_name} ({symbol})</h2>\n                            <h3>‚Çπ{current_price:.2f} \n                            <span style=\"color: {'#00d562' if change >= 0 else '#f85149'}\">\n                            {'+' if change >= 0 else ''}{change:.2f} ({change_pct:+.2f}%)</span></h3>\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n\n                        # Main price chart\n                        fig_main = go.Figure()\n\n                        # Candlestick chart\n                        fig_main.add_trace(go.Candlestick(\n                            x=data.index,\n                            open=data['Open'],\n                            high=data['High'],\n                            low=data['Low'],\n                            close=data['Close'],\n                            name=\"Price\",\n                            increasing_line_color='#00d562',\n                            decreasing_line_color='#f85149'\n                        ))\n\n                        # Add indicators based on user selection\n                        if show_sma:\n                            fig_main.add_trace(go.Scatter(\n                                x=data.index, y=data['SMA_20'],\n                                line=dict(color='#ff9500', width=1),\n                                name='SMA 20'\n                            ))\n                            fig_main.add_trace(go.Scatter(\n                                x=data.index, y=data['SMA_50'],\n                                line=dict(color='#0969da', width=1),\n                                name='SMA 50'\n                            ))\n\n                        if show_bb:\n                            fig_main.add_trace(go.Scatter(\n                                x=data.index, y=data['BB_Upper'],\n                                line=dict(color='#8b949e', width=1),\n                                name='BB Upper', opacity=0.7\n                            ))\n                            fig_main.add_trace(go.Scatter(\n                                x=data.index, y=data['BB_Lower'],\n                                line=dict(color='#8b949e', width=1),\n                                name='BB Lower', opacity=0.7,\n                                fill='tonexty', fillcolor='rgba(139, 148, 158, 0.1)'\n                            ))\n\n                        if show_supertrend:\n                            # Color supertrend based on direction\n                            fig_main.add_trace(go.Scatter(\n                                x=data.index, y=data['Supertrend'],\n                                line=dict(color='#EB4511', width=2),\n                                name='Supertrend'\n                            ))\n\n                        fig_main.update_layout(\n                            title=f\"{symbol} - Price Chart with Indicators\",\n                            template=\"plotly_dark\",\n                            height=600,\n                            xaxis_rangeslider_visible=False,\n                            showlegend=True\n                        )\n\n                        st.plotly_chart(fig_main, use_container_width=True)\n\n                        # Sub-charts for oscillators\n                        if show_rsi:\n                            fig_rsi = go.Figure()\n                            fig_rsi.add_trace(go.Scatter(\n                                x=data.index, y=data['RSI'],\n                                line=dict(color='#a855f7', width=2),\n                                name='RSI'\n                            ))\n\n                            # Add RSI reference lines\n                            fig_rsi.add_hline(y=70, line_dash=\"dash\", \n                                            line_color=\"#f85149\", annotation_text=\"Overbought (70)\")\n                            fig_rsi.add_hline(y=30, line_dash=\"dash\", \n                                            line_color=\"#00d562\", annotation_text=\"Oversold (30)\")\n                            fig_rsi.add_hline(y=50, line_dash=\"dot\", \n                                            line_color=\"#8b949e\", annotation_text=\"Midline (50)\")\n\n                            fig_rsi.update_layout(\n                                title=\"RSI (Relative Strength Index)\",\n                                template=\"plotly_dark\",\n                                height=300,\n                                yaxis=dict(range=[0, 100])\n                            )\n\n                            st.plotly_chart(fig_rsi, use_container_width=True)\n\n                        if show_macd:\n                            fig_macd = go.Figure()\n                            fig_macd.add_trace(go.Scatter(\n                                x=data.index, y=data['MACD'],\n                                line=dict(color='#0969da', width=2),\n                                name='MACD'\n                            ))\n                            fig_macd.add_trace(go.Scatter(\n                                x=data.index, y=data['MACD_Signal'],\n                                line=dict(color='#f85149', width=1),\n                                name='Signal'\n                            ))\n                            fig_macd.add_trace(go.Bar(\n                                x=data.index, y=data['MACD_Histogram'],\n                                name='Histogram', marker_color='#8b949e',\n                                opacity=0.7\n                            ))\n\n                            fig_macd.update_layout(\n                                title=\"MACD (Moving Average Convergence Divergence)\",\n                                template=\"plotly_dark\",\n                                height=300\n                            )\n\n                            st.plotly_chart(fig_macd, use_container_width=True)\n\n                        if show_fisher:\n                            fig_fisher = go.Figure()\n                            fig_fisher.add_trace(go.Scatter(\n                                x=data.index, y=data['Fisher'],\n                                line=dict(color='#00d562', width=2),\n                                name='Fisher Transform'\n                            ))\n                            fig_fisher.add_trace(go.Scatter(\n                                x=data.index, y=data['Fisher_Signal'],\n                                line=dict(color='#f85149', width=1),\n                                name='Fisher Signal'\n                            ))\n\n                            fig_fisher.update_layout(\n                                title=\"Fisher Transform\",\n                                template=\"plotly_dark\",\n                                height=300\n                            )\n\n                            st.plotly_chart(fig_fisher, use_container_width=True)\n\n                        if show_stoch:\n                            fig_stoch = go.Figure()\n                            fig_stoch.add_trace(go.Scatter(\n                                x=data.index, y=data['Stoch_K'],\n                                line=dict(color='#EB4511', width=2),\n                                name='%K'\n                            ))\n                            fig_stoch.add_trace(go.Scatter(\n                                x=data.index, y=data['Stoch_D'],\n                                line=dict(color='#0969da', width=1),\n                                name='%D'\n                            ))\n\n                            # Add reference lines\n                            fig_stoch.add_hline(y=80, line_dash=\"dash\", \n                                              line_color=\"#f85149\", annotation_text=\"Overbought (80)\")\n                            fig_stoch.add_hline(y=20, line_dash=\"dash\", \n                                              line_color=\"#00d562\", annotation_text=\"Oversold (20)\")\n\n                            fig_stoch.update_layout(\n                                title=\"Stochastic Oscillator\",\n                                template=\"plotly_dark\",\n                                height=300,\n                                yaxis=dict(range=[0, 100])\n                            )\n\n                            st.plotly_chart(fig_stoch, use_container_width=True)\n\n                        # Volume chart\n                        fig_volume = go.Figure()\n                        fig_volume.add_trace(go.Bar(\n                            x=data.index, y=data['Volume'],\n                            name='Volume',\n                            marker_color='#8b949e',\n                            opacity=0.7\n                        ))\n\n                        fig_volume.update_layout(\n                            title=\"Volume Analysis\",\n                            template=\"plotly_dark\",\n                            height=250\n                        )\n\n                        st.plotly_chart(fig_volume, use_container_width=True)\n\n                        if show_volume_profile:\n                            # Volume Profile\n                            vp_data = volume_profile(data['Close'], data['Volume'])\n\n                            fig_vp = go.Figure()\n                            fig_vp.add_trace(go.Bar(\n                                y=vp_data['price'],\n                                x=vp_data['volume'],\n                                orientation='h',\n                                name='Volume Profile',\n                                marker_color='#EB4511',\n                                opacity=0.7\n                            ))\n\n                            fig_vp.update_layout(\n                                title=\"Volume Profile\",\n                                template=\"plotly_dark\",\n                                height=400,\n                                xaxis_title=\"Volume\",\n                                yaxis_title=\"Price Level\"\n                            )\n\n                            st.plotly_chart(fig_vp, use_container_width=True)\n\n                        # Technical Analysis Summary\n                        st.markdown(\"### üìä Technical Analysis Summary\")\n\n                        col1, col2, col3, col4 = st.columns(4)\n\n                        with col1:\n                            current_rsi = data['RSI'].iloc[-1]\n                            rsi_signal = \"Overbought\" if current_rsi > 70 else \"Oversold\" if current_rsi < 30 else \"Neutral\"\n                            rsi_color = \"#f85149\" if current_rsi > 70 else \"#00d562\" if current_rsi < 30 else \"#8b949e\"\n\n                            st.metric(\"RSI Signal\", rsi_signal, f\"{current_rsi:.1f}\")\n\n                        with col2:\n                            st_direction = data['ST_Direction'].iloc[-1]\n                            st_signal = \"üü¢ Bullish\" if st_direction > 0 else \"üî¥ Bearish\"\n                            st.metric(\"Supertrend\", st_signal)\n\n                        with col3:\n                            # MACD signal\n                            if 'MACD' in data.columns and 'MACD_Signal' in data.columns:\n                                macd_diff = data['MACD'].iloc[-1] - data['MACD_Signal'].iloc[-1]\n                                macd_signal = \"üü¢ Bullish\" if macd_diff > 0 else \"üî¥ Bearish\"\n                                st.metric(\"MACD Signal\", macd_signal)\n                            else:\n                                st.metric(\"MACD Signal\", \"Not Available\")\n\n                        with col4:\n                            # Volume trend\n                            recent_volume = data['Volume'].iloc[-5:].mean()\n                            avg_volume = data['Volume'].mean()\n                            volume_trend = \"üî• High\" if recent_volume > avg_volume * 1.5 else \"üìâ Low\" if recent_volume < avg_volume * 0.5 else \"‚û°Ô∏è Normal\"\n                            st.metric(\"Volume Trend\", volume_trend)\n\n            except Exception as e:\n                st.error(f\"‚ùå Error loading chart: {str(e)}\")\n                st.info(\"Please check the symbol and try again. Make sure to use NSE symbols like RELIANCE, TCS, INFY etc.\")\n\n    # ‚îÄ‚îÄ TAB 5: AI INSIGHTS (Moved from Tab 4) ‚îÄ‚îÄ\n    with tab5:\n        st.header(\"AI Market Insights\")\n        try:\n            # AI-powered market analysis\n            with st.spinner(\"Generating AI insights...\"):\n                insights = get_market_sentiment_analysis()\n                if insights:\n                    st.markdown(\"### ü§ñ AI Market Analysis\")\n                    st.write(insights.get('analysis',\n                                          'Analysis not available'))\n\n                    col1, col2, col3 = st.columns(3)\n                    with col1:\n                        st.metric(\"Probability Score\",\n                                  f\"{insights.get('probability', 0):.1%}\",\n                                  help=\"AI confidence in market direction\")\n\n                    with col2:\n                        st.metric(\"Trend Direction\",\n                                  insights.get('direction', 'Neutral'),\n                                  help=\"Expected market movement\")\n\n                    with col3:\n                        st.metric(\"Time Horizon\",\n                                  insights.get('duration', 'N/A'),\n                                  help=\"Expected duration of trend\")\n                else:\n                    st.info(\"AI insights temporarily unavailable\")\n        except Exception as e:\n            st.error(f\"Error generating AI insights: {str(e)}\")\n\n    # Footer\n    st.markdown(\"---\")\n    st.markdown(\n        \"üöÄ **Dravyum AI Trading Agent** | Real-time Indian market analysis with AI-powered insights | \"\n        f\"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":36062},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"beautifulsoup4>=4.13.4\",\n    \"matplotlib>=3.10.5\",\n    \"numpy>=2.3.2\",\n    \"openai>=1.99.9\",\n    \"pandas>=2.3.1\",\n    \"plotly>=6.3.0\",\n    \"requests>=2.32.4\",\n    \"schedule>=1.2.2\",\n    \"scikit-learn>=1.7.1\",\n    \"seaborn>=0.13.2\",\n    \"streamlit>=1.48.1\",\n    \"trafilatura>=2.0.0\",\n    \"twilio>=9.7.0\",\n    \"yfinance>=0.2.65\",\n]\n","size_bytes":477},"replit.md":{"content":"# TRADESENSEI - AI Trading Agent\n\n## Overview\n\nTRADESENSEI is a luxury-branded, comprehensive AI-powered trading analysis platform specifically designed for Indian stock markets (NSE/BSE). The application provides real-time market data, fundamental and technical analysis, portfolio tracking, stock screening, AI-driven insights, and automated reporting capabilities. Built with Streamlit as the frontend framework, it integrates multiple data sources and AI services to deliver actionable trading intelligence with a premium user experience featuring a sleek black background with white text for optimal readability and professional appearance.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\nTechnical Requirements: Must use ONLY free and open-source tools (no paid APIs or services).\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: Streamlit with multi-page application structure\n- **Branding**: TRADESENSEI master trading platform with martial arts (ü•ã) iconography\n- **Color Palette**: Sleek black background (#000000) with white text (#FFFFFF) for premium professional appearance\n- **Layout**: Wide layout with sidebar navigation and responsive design\n- **Visualization**: Plotly for interactive charts (candlestick, volume, gauges, pie charts) with matplotlib for specialized histograms\n- **Styling**: Custom CSS for enhanced UI/UX with gradient backgrounds, luxury metric cards, and themed components\n- **Pages**: Modular page structure with 5 main sections (Market Dashboard, Stock Screener, Portfolio Tracker, AI Analysis, Reports & Settings)\n- **Visual Elements**: Gradient headers, bordered metric containers, luxury button styling with hover effects\n\n### Backend Architecture\n- **Data Processing**: Pandas and NumPy for data manipulation and numerical computations\n- **Market Data Provider**: Yahoo Finance (yfinance) as primary data source for Indian stocks\n- **Stock Universe**: Predefined list of major Indian stocks (NIFTY 50 and additional blue-chip stocks)\n- **Caching Strategy**: Time-based caching system for market data with 1-hour expiry\n- **Concurrent Processing**: ThreadPoolExecutor for parallel stock data fetching\n- **File Storage**: JSON-based persistence for portfolio data, settings, and user preferences\n\n### AI Integration (Free & Open Source)\n- **AI Provider**: Statistical analysis and machine learning algorithms (scikit-learn) for market insights\n- **AI Capabilities**: \n  - Market sentiment analysis using technical indicators and statistical models\n  - Stock probability analysis using rule-based scoring systems\n  - Daily market summaries with statistical commentary\n  - Portfolio risk analysis using quantitative methods\n  - Automated stock recommendations based on technical and fundamental scoring\n\n### Data Management\n- **Market Data**: Real-time and historical stock prices, volumes, and market indices\n- **Fundamental Analysis**: Financial ratios, valuation metrics, profitability indicators\n- **Technical Analysis**: Moving averages, RSI, MACD, Bollinger Bands, breakout detection\n- **Portfolio Management**: Holdings tracking, performance calculation, sector allocation\n- **Screening Engine**: Multi-criteria stock filtering with pre-built and custom strategies\n\n### Automation & Scheduling (Free & Open Source)\n- **Job Scheduler**: Schedule library for automated tasks\n- **Notification System**: File-based notification system with HTML reports and JSON logs\n- **Automated Reports**: Daily market summaries, portfolio updates, and alert notifications saved locally\n- **Market Timing**: IST-based scheduling aligned with Indian market hours (9:15 AM - 3:30 PM)\n\n### Data Processing Patterns\n- **Modular Utilities**: Separate modules for market data, fundamentals, AI analysis, portfolio management, and notifications\n- **Error Handling**: Comprehensive exception handling with fallback mechanisms\n- **Data Validation**: Input validation and data quality checks throughout the pipeline\n- **Performance Optimization**: Caching, parallel processing, and efficient data structures\n- **Advanced Analytics**: NIFTY breakout analysis with matplotlib histograms for 6-8 day range visualization\n- **Technical Indicators**: RSI, Supertrend, and quarterly earnings screening capabilities\n\n## External Dependencies\n\n### Financial Data Services\n- **Yahoo Finance API**: Primary source for Indian stock market data (NSE/BSE)\n- **Real-time Data**: Live price feeds and market status information\n\n### AI and Machine Learning (Free & Open Source)\n- **Scikit-learn**: Statistical models and machine learning algorithms for market analysis\n- **NumPy/Pandas**: Mathematical computations and data processing\n- **Rule-based Systems**: Custom algorithms for sentiment analysis and stock scoring\n\n### Communication Services (Free & Open Source)\n- **File-based Notifications**: HTML reports and JSON logs stored locally\n  - Reports directory for viewing market summaries\n  - Notifications directory for alert messages\n  - No external API dependencies required\n\n### Python Libraries\n- **Web Framework**: Streamlit for the user interface\n- **Data Processing**: pandas, numpy for data manipulation\n- **Visualization**: plotly for interactive charts and graphs\n- **Financial Data**: yfinance for market data retrieval\n- **HTTP Requests**: requests for API calls\n- **Scheduling**: schedule library for automated tasks\n- **Threading**: concurrent.futures for parallel processing\n- **Date/Time**: datetime for temporal operations\n\n### Environment Configuration\n- **API Keys**: OpenAI, Twilio credentials via environment variables\n- **Email Configuration**: SMTP settings for notification delivery\n- **Phone Numbers**: Recipient contact information for alerts\n- **File Storage**: Local JSON files for data persistence\n\n### Market-Specific Integrations\n- **NSE/BSE Data**: Indian stock exchange data through Yahoo Finance\n- **Currency**: INR-based pricing and calculations\n- **Market Hours**: Indian Standard Time (IST) scheduling\n- **Stock Symbols**: .NS suffix handling for NSE-listed securities","size_bytes":6065},"pages/1_üìà_Market_Dashboard.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nimport numpy as np\nimport sys\nimport os\n\n# Add the parent directory to the path to import utils\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils.market_data import (get_nifty_data, get_top_gainers_losers,\n                               get_market_status, get_real_time_price,\n                               calculate_technical_indicators,\n                               detect_breakouts)\nfrom utils.fundamentals import get_fundamental_data\n\nst.set_page_config(page_title=\"Market Dashboard - TRADESENSEI\", page_icon=\"ü•ã\", layout=\"wide\")\n\n\ndef create_candlestick_chart(data, title):\n    \"\"\"Create a candlestick chart\"\"\"\n    fig = go.Figure(data=go.Candlestick(x=data.index,\n                                        open=data['Open'],\n                                        high=data['High'],\n                                        low=data['Low'],\n                                        close=data['Close'],\n                                        name=title))\n\n    fig.update_layout(title=title,\n                      xaxis_title=\"Date\",\n                      yaxis_title=\"Price (‚Çπ)\",\n                      height=400,\n                      showlegend=False)\n\n    return fig\n\n\ndef create_volume_chart(data):\n    \"\"\"Create volume chart\"\"\"\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Bar(x=data.index,\n               y=data['Volume'],\n               name='Volume',\n               marker_color='rgba(255, 107, 107, 0.7)'))\n\n    fig.update_layout(title=\"Trading Volume\",\n                      xaxis_title=\"Date\",\n                      yaxis_title=\"Volume\",\n                      height=200)\n\n    return fig\n\n\n# Add luxury styling\nst.markdown(\"\"\"\n<style>\n    /* Luxury color palette: Black, #C6AC8E (warm beige), #EAEOD5 (light cream) */\n    .stApp {\n        background-color: #EAEOD5;\n    }\n    \n    /* Header styling */\n    .main-header {\n        background: linear-gradient(135deg, #000000 0%, #C6AC8E 100%);\n        padding: 1.5rem;\n        border-radius: 15px;\n        color: #EAEOD5;\n        text-align: center;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n    }\n    \n    /* Text styling */\n    h1, h2, h3 {\n        color: #000000;\n        font-weight: bold;\n    }\n    \n    /* Metric styling */\n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        border: 2px solid #000000;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    }\n    \n    /* Button styling */\n    .stButton > button {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        color: #000000;\n        border: 2px solid #000000;\n        border-radius: 10px;\n        font-weight: bold;\n    }\n    \n    .stButton > button:hover {\n        background: linear-gradient(145deg, #000000, #C6AC8E);\n        color: #EAEOD5;\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\n\ndef main():\n    # DRAVYUM header for Market Dashboard\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 2.5rem;\">Market Dashboard</h1>\n        <p style=\"margin: 0.3rem 0 0 0; opacity: 0.9;\">Real-time market intelligence and analysis</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Market status indicator\n    market_status = get_market_status()\n\n    col1, col2, col3 = st.columns([1, 1, 2])\n\n    with col1:\n        if market_status.get('is_open', False):\n            st.success(\"üü¢ Market OPEN\")\n        else:\n            st.error(\"üî¥ Market CLOSED\")\n\n    with col2:\n        st.info(f\"üïí {market_status.get('current_time', 'N/A')}\")\n\n    with col3:\n        st.info(f\"üìÖ Next Session: {market_status.get('next_open', 'N/A')}\")\n\n    # Main indices overview\n    st.header(\"üìä Major Indices\")\n\n    indices = {\n        \"NIFTY 50\": \"^NSEI\",\n        \"SENSEX\": \"^BSESN\",\n        \"BANK NIFTY\": \"^NSEBANK\",\n        \"NIFTY IT\": \"^CNXIT\"\n    }\n\n    index_cols = st.columns(len(indices))\n\n    for i, (name, symbol) in enumerate(indices.items()):\n        with index_cols[i]:\n            try:\n                ticker = yf.Ticker(symbol)\n                hist = ticker.history(period=\"2d\")\n\n                if not hist.empty and len(hist) >= 2:\n                    current = hist['Close'].iloc[-1]\n                    previous = hist['Close'].iloc[-2]\n                    change = current - previous\n                    change_pct = (change / previous) * 100\n\n                    st.metric(label=name,\n                              value=f\"‚Çπ{current:,.2f}\",\n                              delta=f\"{change:+.2f} ({change_pct:+.2f}%)\")\n                else:\n                    st.metric(label=name, value=\"Data unavailable\")\n\n            except Exception as e:\n                st.metric(label=name, value=\"Error loading data\")\n\n    # AI Market Summary Section\n    st.header(\"ü§ñ AI Market Summary\")\n\n    try:\n        from utils.ai_analysis import generate_daily_market_summary\n\n        with st.spinner(\"Generating AI market analysis...\"):\n            ai_summary = generate_daily_market_summary()\n\n            if ai_summary:\n                # Display summary in an attractive format\n                st.markdown(f\"\"\"\n                    <div style=\"\n                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n                        padding: 20px; \n                        border-radius: 10px; \n                        color: white;\n                        margin: 10px 0;\n                    \">\n                        <h3 style=\"color: white; margin: 0 0 15px 0;\">üìä Market Intelligence Report</h3>\n                        <div style=\"background: rgba(255,255,255,0.1); padding: 15px; border-radius: 5px;\">\n                            {ai_summary.replace(chr(10), '<br>')}\n                        </div>\n                    </div>\n                    \"\"\",\n                            unsafe_allow_html=True)\n            else:\n                st.info(\n                    \"AI market summary is currently being generated. Please refresh the page in a moment.\"\n                )\n\n    except Exception as e:\n        st.error(f\"Error generating AI market summary: {str(e)}\")\n\n    # Detailed NIFTY analysis\n    st.header(\"üéØ NIFTY 50 Detailed Analysis\")\n\n    try:\n        nifty_data = get_nifty_data(period=\"3mo\")\n\n        if not nifty_data.empty:\n            # Add technical indicators\n            nifty_with_indicators = calculate_technical_indicators(nifty_data)\n\n            col1, col2 = st.columns([2, 1])\n\n            with col1:\n                # Candlestick chart\n                candlestick_fig = create_candlestick_chart(\n                    nifty_data.tail(60), \"NIFTY 50 - Last 60 Days\")\n\n                # Add moving averages\n                if 'SMA_20' in nifty_with_indicators.columns:\n                    candlestick_fig.add_trace(\n                        go.Scatter(x=nifty_with_indicators.index.tail(60),\n                                   y=nifty_with_indicators['SMA_20'].tail(60),\n                                   mode='lines',\n                                   name='SMA 20',\n                                   line=dict(color='orange', width=1)))\n\n                if 'SMA_50' in nifty_with_indicators.columns:\n                    candlestick_fig.add_trace(\n                        go.Scatter(x=nifty_with_indicators.index.tail(60),\n                                   y=nifty_with_indicators['SMA_50'].tail(60),\n                                   mode='lines',\n                                   name='SMA 50',\n                                   line=dict(color='blue', width=1)))\n\n                candlestick_fig.update_layout(showlegend=True)\n                st.plotly_chart(candlestick_fig, use_container_width=True)\n\n            with col2:\n                # Key technical levels\n                current_price = nifty_data['Close'].iloc[-1]\n                high_52w = nifty_data['High'].max()\n                low_52w = nifty_data['Low'].min()\n\n                st.subheader(\"üìà Technical Levels\")\n                st.metric(\"52W High\", f\"‚Çπ{high_52w:,.2f}\")\n                st.metric(\"52W Low\", f\"‚Çπ{low_52w:,.2f}\")\n\n                if 'RSI' in nifty_with_indicators.columns:\n                    rsi = nifty_with_indicators['RSI'].iloc[-1]\n                    st.metric(\"RSI (14)\", f\"{rsi:.1f}\")\n\n                # Support/Resistance levels\n                st.subheader(\"üéØ Key Levels\")\n                recent_data = nifty_data.tail(20)\n                support = recent_data['Low'].min()\n                resistance = recent_data['High'].max()\n\n                st.metric(\"Support\", f\"‚Çπ{support:,.2f}\")\n                st.metric(\"Resistance\", f\"‚Çπ{resistance:,.2f}\")\n\n            # Volume analysis\n            volume_fig = create_volume_chart(nifty_data.tail(60))\n            st.plotly_chart(volume_fig, use_container_width=True)\n\n        else:\n            st.error(\"Unable to fetch NIFTY data\")\n\n    except Exception as e:\n        st.error(f\"Error in NIFTY analysis: {str(e)}\")\n\n    # Top movers section\n    st.header(\"üî• Market Movers\")\n\n    try:\n        gainers, losers = get_top_gainers_losers()\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.subheader(\"üü¢ Top Gainers\")\n            if not gainers.empty:\n                # Color code the dataframe\n                def color_positive(val):\n                    return 'color: green' if val > 0 else ''\n\n                styled_gainers = gainers.head(10).style.applymap(\n                    color_positive, subset=['Change', '% Change'])\n                st.dataframe(styled_gainers, use_container_width=True)\n            else:\n                st.info(\"No gainers data available\")\n\n        with col2:\n            st.subheader(\"üî¥ Top Losers\")\n            if not losers.empty:\n\n                def color_negative(val):\n                    return 'color: red' if val < 0 else ''\n\n                styled_losers = losers.head(10).style.applymap(\n                    color_negative, subset=['Change', '% Change'])\n                st.dataframe(styled_losers, use_container_width=True)\n            else:\n                st.info(\"No losers data available\")\n\n    except Exception as e:\n        st.error(f\"Error loading top movers: {str(e)}\")\n\n    # Sectoral performance\n    st.header(\"üè≠ Sector Performance\")\n\n    try:\n        # Sample sector indices (in production, this would fetch real sector data)\n        sector_data = {\n            'Bank Nifty': '^NSEBANK',\n            'IT': '^CNXIT',\n            'Auto': '^CNXAUTO',\n            'Pharma': '^CNXPHARMA',\n            'FMCG': '^CNXFMCG'\n        }\n\n        sector_performance = []\n\n        for sector, symbol in sector_data.items():\n            try:\n                ticker = yf.Ticker(symbol)\n                hist = ticker.history(period=\"2d\")\n\n                if not hist.empty and len(hist) >= 2:\n                    current = hist['Close'].iloc[-1]\n                    previous = hist['Close'].iloc[-2]\n                    change_pct = ((current - previous) / previous) * 100\n\n                    sector_performance.append({\n                        'Sector': sector,\n                        'Change %': change_pct,\n                        'Current': current\n                    })\n            except:\n                continue\n\n        if sector_performance:\n            sector_df = pd.DataFrame(sector_performance)\n            sector_df = sector_df.sort_values('Change %', ascending=False)\n\n            # Create sector performance chart\n            fig = px.bar(sector_df,\n                         x='Sector',\n                         y='Change %',\n                         title=\"Sectoral Performance Today\",\n                         color='Change %',\n                         color_continuous_scale=['red', 'white', 'green'])\n            fig.update_layout(height=400)\n            st.plotly_chart(fig, use_container_width=True)\n\n            # Show sector table\n            st.dataframe(sector_df, use_container_width=True, hide_index=True)\n        else:\n            st.info(\"Sector data temporarily unavailable\")\n\n    except Exception as e:\n        st.error(f\"Error loading sector performance: {str(e)}\")\n\n    # Breakout stocks\n    st.header(\"üöÄ Breakout Analysis\")\n\n    try:\n        import matplotlib.pyplot as plt\n        import matplotlib\n        matplotlib.use('Agg')  # Use non-interactive backend\n\n        # Get NIFTY stocks breakout data\n        breakout_result = detect_breakouts()  # Now works without parameters\n        breakout_data = breakout_result.get('breakouts', []) if isinstance(\n            breakout_result, dict) else []\n\n        if breakout_data and len(breakout_data) > 0:\n            col1, col2 = st.columns([2, 1])\n\n            with col1:\n                # Create histogram of breakout ranges using matplotlib\n                fig, ax = plt.subplots(figsize=(10, 6))\n\n                # Extract breakout range data\n                breakout_ranges = []\n                for stock in breakout_data:\n                    if 'breakout_range' in stock:\n                        breakout_ranges.append(stock['breakout_range'])\n\n                if breakout_ranges:\n                    # Create histogram\n                    ax.hist(breakout_ranges,\n                            bins=20,\n                            alpha=0.7,\n                            color='#FF6B6B',\n                            edgecolor='black')\n                    ax.set_xlabel('Breakout Range (Days)', fontsize=12)\n                    ax.set_ylabel('Number of Stocks', fontsize=12)\n                    ax.set_title(\n                        'NIFTY Stocks Breakout Distribution (6-8 Day Range)',\n                        fontsize=14,\n                        fontweight='bold')\n                    ax.grid(True, alpha=0.3)\n\n                    # Add statistics text\n                    mean_range = np.mean(breakout_ranges)\n                    ax.axvline(mean_range,\n                               color='red',\n                               linestyle='--',\n                               linewidth=2,\n                               label=f'Mean: {mean_range:.1f} days')\n                    ax.legend()\n\n                    # Style the plot\n                    plt.tight_layout()\n                    st.pyplot(fig)\n                    plt.close()  # Close figure to free memory\n                else:\n                    st.info(\"No breakout range data available for histogram\")\n\n            with col2:\n                st.subheader(\"üìä Breakout Statistics\")\n\n                if breakout_ranges:\n                    st.metric(\"Total Breakouts\", len(breakout_ranges))\n                    st.metric(\"Average Range\",\n                              f\"{np.mean(breakout_ranges):.1f} days\")\n                    st.metric(\"Max Range\", f\"{max(breakout_ranges):.1f} days\")\n                    st.metric(\"Min Range\", f\"{min(breakout_ranges):.1f} days\")\n\n                # Filter for 6-8 day range breakouts\n                filtered_breakouts = [\n                    stock for stock in breakout_data\n                    if stock.get('breakout_range', 0) >= 6\n                    and stock.get('breakout_range', 0) <= 8\n                ]\n\n                if filtered_breakouts:\n                    st.subheader(\"üéØ 6-8 Day Breakouts\")\n                    for stock in filtered_breakouts[:5]:  # Show top 5\n                        symbol = stock.get('symbol', 'Unknown')\n                        breakout_range = stock.get('breakout_range', 0)\n                        strength = stock.get('strength', 0)\n\n                        st.write(\n                            f\"**{symbol}**: {breakout_range:.1f} days (Strength: {strength:.1f})\"\n                        )\n\n            # Display breakout table\n            st.subheader(\"üìà Recent Breakouts\")\n\n            breakout_df = pd.DataFrame([\n                {\n                    'Symbol': stock.get('symbol', ''),\n                    'Current Price': f\"‚Çπ{stock.get('current_price', 0):.2f}\",\n                    'Breakout Range (Days)':\n                    f\"{stock.get('breakout_range', 0):.1f}\",\n                    'Strength Score': f\"{stock.get('strength', 0):.1f}\",\n                    'Volume Ratio': f\"{stock.get('volume_ratio', 1):.1f}x\"\n                } for stock in breakout_data[:15]  # Top 15 breakouts\n            ])\n\n            if not breakout_df.empty:\n                st.dataframe(breakout_df,\n                             use_container_width=True,\n                             hide_index=True)\n            else:\n                st.info(\"No breakout data available at the moment\")\n\n        else:\n            st.info(\n                \"üîç No current breakouts detected. Breakout analysis will update during market hours.\"\n            )\n\n            # Show a sample histogram for demonstration\n            st.subheader(\"üìä Sample NIFTY Breakout Distribution\")\n\n            # Create sample data for demonstration\n            np.random.seed(42)\n            sample_ranges = np.random.normal(7, 2, 100)  # Mean 7 days, std 2\n            sample_ranges = np.clip(sample_ranges, 3,\n                                    15)  # Clip to reasonable range\n\n            fig, ax = plt.subplots(figsize=(10, 6))\n            ax.hist(sample_ranges,\n                    bins=15,\n                    alpha=0.7,\n                    color='#4ECDC4',\n                    edgecolor='black')\n            ax.set_xlabel('Breakout Range (Days)', fontsize=12)\n            ax.set_ylabel('Number of Stocks', fontsize=12)\n            ax.set_title('Sample NIFTY Stocks Breakout Distribution',\n                         fontsize=14,\n                         fontweight='bold')\n            ax.grid(True, alpha=0.3)\n            ax.axvline(np.mean(sample_ranges),\n                       color='red',\n                       linestyle='--',\n                       linewidth=2,\n                       label=f'Mean: {np.mean(sample_ranges):.1f} days')\n            ax.legend()\n            plt.tight_layout()\n            st.pyplot(fig)\n            plt.close()\n\n            st.info(\n                \"This is a sample histogram. Live data will appear when market breakouts are detected.\"\n            )\n\n    except Exception as e:\n        st.error(f\"Error in breakout analysis: {str(e)}\")\n        st.info(\"Breakout analysis temporarily unavailable\")\n\n    # Quick stock lookup\n    st.header(\"üîç Quick Stock Lookup\")\n\n    col1, col2 = st.columns([1, 2])\n\n    with col1:\n        symbol_input = st.text_input(\"Enter Stock Symbol (e.g., RELIANCE)\",\n                                     value=\"RELIANCE\")\n\n        if st.button(\"Get Quote\", use_container_width=True):\n            if symbol_input:\n                with col2:\n                    with st.spinner(f\"Fetching data for {symbol_input}...\"):\n                        try:\n                            # Get real-time price\n                            current_price = get_real_time_price(symbol_input)\n\n                            if current_price:\n                                # Get additional data\n                                stock_data = yf.Ticker(\n                                    f\"{symbol_input}.NS\").history(period=\"5d\")\n\n                                if not stock_data.empty:\n                                    prev_price = stock_data['Close'].iloc[\n                                        -2] if len(\n                                            stock_data) > 1 else current_price\n                                    change = current_price - prev_price\n                                    change_pct = (change / prev_price) * 100\n\n                                    st.metric(\n                                        label=symbol_input,\n                                        value=f\"‚Çπ{current_price:.2f}\",\n                                        delta=\n                                        f\"{change:+.2f} ({change_pct:+.2f}%)\")\n\n                                    # Get fundamental data\n                                    fundamental = get_fundamental_data(\n                                        symbol_input)\n                                    if fundamental:\n                                        basic_info = fundamental.get(\n                                            'basic_info', {})\n                                        valuation = fundamental.get(\n                                            'valuation_ratios', {})\n\n                                        info_col1, info_col2 = st.columns(2)\n\n                                        with info_col1:\n                                            st.write(\n                                                f\"**Company:** {basic_info.get('company_name', 'N/A')}\"\n                                            )\n                                            st.write(\n                                                f\"**Sector:** {basic_info.get('sector', 'N/A')}\"\n                                            )\n\n                                        with info_col2:\n                                            pe_ratio = valuation.get(\n                                                'pe_ratio')\n                                            if pe_ratio:\n                                                st.write(\n                                                    f\"**P/E Ratio:** {pe_ratio:.2f}\"\n                                                )\n                                            market_cap = basic_info.get(\n                                                'market_cap', 0)\n                                            if market_cap:\n                                                st.write(\n                                                    f\"**Market Cap:** ‚Çπ{market_cap/10000000:.1f} Cr\"\n                                                )\n                                else:\n                                    st.error(\"Unable to fetch historical data\")\n                            else:\n                                st.error(\n                                    f\"Unable to fetch price for {symbol_input}\"\n                                )\n\n                        except Exception as e:\n                            st.error(f\"Error fetching data: {str(e)}\")\n\n    # Auto-refresh option\n    st.sidebar.header(\"‚öôÔ∏è Dashboard Settings\")\n\n    auto_refresh = st.sidebar.checkbox(\"Auto-refresh (30 seconds)\")\n\n    if auto_refresh:\n        st.sidebar.info(\n            \"Dashboard will refresh automatically every 30 seconds\")\n        time.sleep(30)\n        st.rerun()\n\n    # Manual refresh button\n    if st.sidebar.button(\"üîÑ Refresh Data\", use_container_width=True):\n        st.rerun()\n\n    # Last updated timestamp\n    st.sidebar.markdown(\n        f\"**Last updated:** {datetime.now().strftime('%H:%M:%S')}\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":22969},"pages/2_üîç_Stock_Screener.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport sys\nimport os\nfrom datetime import datetime\n\n# Add the parent directory to the path to import utils\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils.screener import StockScreener\n\nst.set_page_config(page_title=\"Stock Screener - TRADESENSEI\", page_icon=\"ü•ã\", layout=\"wide\")\n\n# Add luxury styling\nst.markdown(\"\"\"\n<style>\n    .stApp {\n        background-color: #EAEOD5;\n    }\n    \n    .main-header {\n        background: linear-gradient(120deg, #000000 0%, #EAE0D5 100%);\n        padding: 1.5rem;\n        border-radius: 15px;\n        color: #EAEOD5;\n        text-align: center;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n    }\n    \n    h1, h2, h3 {\n        color: #000000;\n        font-weight: bold;\n    }\n    \n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        border: 2px solid #000000;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    }\n    \n    .stButton > button {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        color: #000000;\n        border: 2px solid #000000;\n        border-radius: 10px;\n        font-weight: bold;\n    }\n    \n    .stButton > button:hover {\n        background: linear-gradient(145deg, #000000, #C6AC8E);\n        color: #EAEOD5;\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\n\ndef main():\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 2.5rem;\">Screeners</h1>\n        <p style=\"margin: 0.3rem 0 0 0; opacity: 0.9;\"> Our Advanced screening tools for Indian markets</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Initialize screener\n    if 'screener' not in st.session_state:\n        st.session_state.screener = StockScreener()\n\n    screener = st.session_state.screener\n\n    # Screening options\n    screening_type = st.radio(\n        \"Choose Screening Method:\",\n        [\"Pre-built Screens\", \"Custom Screen\", \"Combined Screen\"],\n        horizontal=True)\n\n    if screening_type == \"Pre-built Screens\":\n        st.header(\"üìã Pre-built Screening Strategies\")\n\n        strategy = st.selectbox(\"Select Strategy:\", [\n            \"RSI Analysis\", \"Supertrend Signals\", \"Quarterly Earnings\",\n            \"Momentum Stocks\", \"Value Stocks\", \"Growth Stocks\",\n            \"Dividend Stocks\", \"Quality Stocks\"\n        ])\n\n        col1, col2 = st.columns([3, 1])\n\n        with col2:\n            if st.button(\"üîç Run Screen\", use_container_width=True):\n                with st.spinner(f\"Screening for {strategy.lower()}...\"):\n                    try:\n                        if strategy == \"RSI Analysis\":\n                            # Get RSI parameters from sidebar\n                            with st.sidebar:\n                                st.subheader(\"RSI Parameters\")\n                                rsi_condition = st.selectbox(\n                                    \"RSI Condition\",\n                                    [\"oversold\", \"overbought\", \"range\"])\n                                rsi_low = st.slider(\"RSI Low\", 20, 40, 30)\n                                rsi_high = st.slider(\"RSI High\", 60, 80, 70)\n\n                            criteria = {\n                                'rsi_condition': rsi_condition,\n                                'rsi_low': rsi_low,\n                                'rsi_high': rsi_high\n                            }\n                            results = screener.rsi_screen(criteria)\n\n                        elif strategy == \"Supertrend Signals\":\n                            # Get Supertrend parameters\n                            with st.sidebar:\n                                st.subheader(\"Supertrend Parameters\")\n                                signal_type = st.selectbox(\n                                    \"Signal Type\", [\"buy\", \"sell\"])\n\n                            criteria = {'signal_type': signal_type}\n                            results = screener.supertrend_screen(criteria)\n\n                        elif strategy == \"Quarterly Earnings\":\n                            # Get earnings parameters\n                            with st.sidebar:\n                                st.subheader(\"Earnings Parameters\")\n                                min_growth = st.slider(\"Min Profit Growth (%)\",\n                                                       0, 50, 10)\n                                min_revenue_growth = st.slider(\n                                    \"Min Revenue Growth (%)\", 0, 30, 5)\n                                max_pe = st.slider(\"Max P/E Ratio\", 10, 50, 25)\n\n                            criteria = {\n                                'min_growth': min_growth,\n                                'min_revenue_growth': min_revenue_growth,\n                                'max_pe': max_pe\n                            }\n                            results = screener.quarterly_earnings_screen(\n                                criteria)\n\n                        elif strategy == \"Momentum Stocks\":\n                            results = screener.momentum_screen()\n                        elif strategy == \"Value Stocks\":\n                            results = screener.value_screen()\n                        elif strategy == \"Growth Stocks\":\n                            results = screener.growth_screen()\n                        elif strategy == \"Dividend Stocks\":\n                            results = screener.dividend_screen()\n                        elif strategy == \"Quality Stocks\":\n                            results = screener.quality_screen()\n\n                        st.session_state.screen_results = results\n                        st.session_state.screen_type = strategy\n\n                    except Exception as e:\n                        st.error(f\"Error running screen: {str(e)}\")\n\n        # Strategy descriptions\n        with col1:\n            strategy_descriptions = {\n                \"RSI Analysis\":\n                \"Find stocks with RSI indicating oversold or overbought conditions for potential reversal trades\",\n                \"Supertrend Signals\":\n                \"Identify stocks showing clear buy/sell signals based on Supertrend indicator\",\n                \"Quarterly Earnings\":\n                \"Screen stocks with strong quarterly earnings growth and reasonable valuations\",\n                \"Momentum Stocks\":\n                \"Stocks showing strong upward price movement with high volume and positive technical indicators\",\n                \"Value Stocks\":\n                \"Undervalued stocks with low P/E ratios, good ROE, and dividend yields\",\n                \"Growth Stocks\":\n                \"Companies showing strong revenue and earnings growth potential\",\n                \"Dividend Stocks\":\n                \"Stocks with consistent dividend payments and good yield\",\n                \"Quality Stocks\":\n                \"Companies with strong fundamentals, low debt, and consistent profitability\"\n            }\n\n            st.info(strategy_descriptions.get(strategy, \"\"))\n\n    elif screening_type == \"Custom Screen\":\n        st.header(\"‚öôÔ∏è Custom Screening Criteria\")\n\n        # Create tabs for different criteria types\n        tab1, tab2 = st.tabs(\n            [\"üìä Fundamental Criteria\", \"üìà Technical Criteria\"])\n\n        with tab1:\n            st.subheader(\"Fundamental Filters\")\n\n            col1, col2, col3 = st.columns(3)\n\n            with col1:\n                st.write(\"**Valuation Metrics**\")\n                min_market_cap = st.number_input(\n                    \"Min Market Cap (Cr)\", min_value=0, value=100) * 10000000\n                max_market_cap = st.number_input(\"Max Market Cap (Cr)\",\n                                                 min_value=0,\n                                                 value=100000) * 10000000\n                min_pe = st.number_input(\"Min P/E Ratio\",\n                                         min_value=0.0,\n                                         value=5.0,\n                                         step=0.1)\n                max_pe = st.number_input(\"Max P/E Ratio\",\n                                         min_value=0.0,\n                                         value=50.0,\n                                         step=0.1)\n\n            with col2:\n                st.write(\"**Profitability Metrics**\")\n                min_roe = st.number_input(\n                    \"Min ROE (%)\", min_value=0.0, value=10.0, step=0.1) / 100\n                min_profit_margin = st.number_input(\"Min Profit Margin (%)\",\n                                                    min_value=0.0,\n                                                    value=5.0,\n                                                    step=0.1) / 100\n                max_debt_equity = st.number_input(\"Max Debt/Equity\",\n                                                  min_value=0.0,\n                                                  value=2.0,\n                                                  step=0.1)\n\n            with col3:\n                st.write(\"**Growth & Dividend**\")\n                min_revenue_growth = st.number_input(\n                    \"Min Revenue Growth (%)\", value=-50.0, step=1.0) / 100\n                dividend_required = st.checkbox(\"Must pay dividends\")\n\n                # Sector filter\n                sectors = st.multiselect(\"Filter by Sectors:\", [\n                    \"Technology\", \"Banking\", \"Pharmaceuticals\", \"Oil & Gas\",\n                    \"Automobiles\", \"FMCG\"\n                ])\n\n            # Build fundamental criteria\n            fundamental_criteria = {\n                'min_market_cap': min_market_cap,\n                'max_market_cap': max_market_cap,\n                'min_pe_ratio': min_pe,\n                'max_pe_ratio': max_pe,\n                'min_roe': min_roe,\n                'min_profit_margin': min_profit_margin,\n                'max_debt_to_equity': max_debt_equity,\n                'min_revenue_growth': min_revenue_growth,\n                'dividend_yield': dividend_required,\n                'sectors': sectors if sectors else None\n            }\n\n        with tab2:\n            st.subheader(\"Technical Filters\")\n\n            col1, col2 = st.columns(2)\n\n            with col1:\n                st.write(\"**Price Action**\")\n                price_above_sma20 = st.checkbox(\"Price above SMA 20\")\n                price_above_sma50 = st.checkbox(\"Price above SMA 50\")\n                macd_bullish = st.checkbox(\"MACD Bullish Signal\")\n                breakout_pattern = st.checkbox(\"Recent Breakout\")\n\n            with col2:\n                st.write(\"**Momentum Indicators**\")\n                rsi_min = st.number_input(\"Min RSI\",\n                                          min_value=0,\n                                          max_value=100,\n                                          value=30)\n                rsi_max = st.number_input(\"Max RSI\",\n                                          min_value=0,\n                                          max_value=100,\n                                          value=70)\n                volume_spike = st.checkbox(\"Volume Spike (1.5x avg)\")\n                min_volume = st.number_input(\"Min Daily Volume\",\n                                             min_value=0,\n                                             value=100000)\n\n            # Build technical criteria\n            technical_criteria = {\n                'price_above_sma20': price_above_sma20,\n                'price_above_sma50': price_above_sma50,\n                'macd_bullish': macd_bullish,\n                'breakout_pattern': breakout_pattern,\n                'rsi_min': rsi_min,\n                'rsi_max': rsi_max,\n                'volume_spike': volume_spike,\n                'min_volume': min_volume\n            }\n\n        # Run custom screen\n        if st.button(\"üîç Run Custom Screen\", use_container_width=True):\n            with st.spinner(\"Running custom screen...\"):\n                try:\n                    # Combine criteria\n                    custom_criteria = {\n                        **fundamental_criteria,\n                        **technical_criteria\n                    }\n                    results = screener.custom_screen(custom_criteria)\n\n                    st.session_state.screen_results = results\n                    st.session_state.screen_type = \"Custom Screen\"\n\n                except Exception as e:\n                    st.error(f\"Error running custom screen: {str(e)}\")\n\n    elif screening_type == \"Combined Screen\":\n        st.header(\"üîÑ Combined Fundamental & Technical Screen\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.subheader(\"üìä Fundamental Criteria\")\n            fund_min_roe = st.number_input(\"Min ROE (%)\", value=12.0) / 100\n            fund_max_pe = st.number_input(\"Max P/E Ratio\", value=25.0)\n            fund_min_growth = st.number_input(\"Min Revenue Growth (%)\",\n                                              value=5.0) / 100\n\n            fundamental_criteria = {\n                'min_roe': fund_min_roe,\n                'max_pe_ratio': fund_max_pe,\n                'min_revenue_growth': fund_min_growth\n            }\n\n        with col2:\n            st.subheader(\"üìà Technical Criteria\")\n            tech_price_sma20 = st.checkbox(\"Price above SMA 20\", value=True)\n            tech_rsi_range = st.slider(\"RSI Range\", 0, 100, (40, 70))\n            tech_macd = st.checkbox(\"MACD Bullish\")\n\n            technical_criteria = {\n                'price_above_sma20': tech_price_sma20,\n                'rsi_min': tech_rsi_range[0],\n                'rsi_max': tech_rsi_range[1],\n                'macd_bullish': tech_macd\n            }\n\n        # Weighting\n        st.subheader(\"‚öñÔ∏è Scoring Weights\")\n        col1, col2 = st.columns(2)\n\n        with col1:\n            fund_weight = st.slider(\"Fundamental Weight\", 0.0, 1.0, 0.6, 0.1)\n        with col2:\n            tech_weight = st.slider(\"Technical Weight\", 0.0, 1.0, 0.4, 0.1)\n\n        # Normalize weights\n        total_weight = fund_weight + tech_weight\n        if total_weight > 0:\n            fund_weight = fund_weight / total_weight\n            tech_weight = tech_weight / total_weight\n\n        weights = {'fundamental': fund_weight, 'technical': tech_weight}\n\n        if st.button(\"üîç Run Combined Screen\", use_container_width=True):\n            with st.spinner(\"Running combined screen...\"):\n                try:\n                    results = screener.combined_screen(fundamental_criteria,\n                                                       technical_criteria,\n                                                       weights)\n\n                    st.session_state.screen_results = results\n                    st.session_state.screen_type = \"Combined Screen\"\n\n                except Exception as e:\n                    st.error(f\"Error running combined screen: {str(e)}\")\n\n    # Display results\n    if hasattr(st.session_state,\n               'screen_results') and st.session_state.screen_results:\n        st.header(f\"üìä {st.session_state.screen_type} Results\")\n\n        results = st.session_state.screen_results\n\n        if results:\n            # Summary metrics\n            col1, col2, col3, col4 = st.columns(4)\n\n            with col1:\n                st.metric(\"Stocks Found\", len(results))\n\n            with col2:\n                if screening_type != \"Custom Screen\" and 'financial_score' in results[\n                        0]:\n                    avg_score = sum(\n                        r.get('financial_score', 0)\n                        for r in results) / len(results)\n                    st.metric(\"Avg Financial Score\", f\"{avg_score:.1f}\")\n                elif 'combined_score' in results[0]:\n                    avg_score = sum(\n                        r.get('combined_score', 0)\n                        for r in results) / len(results)\n                    st.metric(\"Avg Combined Score\", f\"{avg_score:.1f}\")\n                else:\n                    st.metric(\"Avg Tech Score\", \"N/A\")\n\n            with col3:\n                sectors = [\n                    r.get('sector', 'Unknown') for r in results\n                    if r.get('sector')\n                ]\n                unique_sectors = len(set(sectors)) if sectors else 0\n                st.metric(\"Sectors Covered\", unique_sectors)\n\n            with col4:\n                market_caps = [\n                    r.get('market_cap', 0) for r in results\n                    if r.get('market_cap', 0) > 0\n                ]\n                avg_mcap = sum(market_caps) / len(\n                    market_caps) / 10000000 if market_caps else 0\n                st.metric(\"Avg Market Cap (Cr)\", f\"‚Çπ{avg_mcap:,.0f}\")\n\n            # Results table\n            df_results = pd.DataFrame(results)\n\n            # Select relevant columns for display\n            display_columns = ['symbol', 'current_price']\n\n            if 'company_name' in df_results.columns:\n                display_columns.insert(1, 'company_name')\n            if 'sector' in df_results.columns:\n                display_columns.append('sector')\n            if 'financial_score' in df_results.columns:\n                display_columns.append('financial_score')\n            if 'technical_score' in df_results.columns:\n                display_columns.append('technical_score')\n            if 'combined_score' in df_results.columns:\n                display_columns.append('combined_score')\n            if 'pe_ratio' in df_results.columns:\n                display_columns.append('pe_ratio')\n            if 'roe' in df_results.columns:\n                display_columns.append('roe')\n            if 'dividend_yield' in df_results.columns:\n                display_columns.append('dividend_yield')\n\n            # Filter and rename columns\n            display_df = df_results[display_columns].copy()\n            display_df.columns = [\n                col.replace('_', ' ').title() for col in display_df.columns\n            ]\n\n            # Format numeric columns\n            numeric_columns = display_df.select_dtypes(\n                include=['float64', 'int64']).columns\n            for col in numeric_columns:\n                if 'Score' in col:\n                    display_df[col] = display_df[col].round(1)\n                elif 'Price' in col:\n                    display_df[col] = display_df[col].round(2)\n                elif 'Ratio' in col or 'Roe' in col or 'Yield' in col:\n                    display_df[col] = display_df[col].round(3)\n\n            st.dataframe(display_df, use_container_width=True, hide_index=True)\n\n            # Sector distribution chart\n            if 'sector' in df_results.columns:\n                sector_counts = df_results['sector'].value_counts()\n\n                if len(sector_counts) > 1:\n                    fig_sector = px.pie(\n                        values=sector_counts.values,\n                        names=sector_counts.index,\n                        title=\"Sector Distribution of Screened Stocks\")\n                    st.plotly_chart(fig_sector, use_container_width=True)\n\n            # Score distribution (if applicable)\n            if 'financial_score' in df_results.columns:\n                fig_score = px.histogram(df_results,\n                                         x='financial_score',\n                                         title=\"Financial Score Distribution\",\n                                         nbins=20)\n                st.plotly_chart(fig_score, use_container_width=True)\n            elif 'combined_score' in df_results.columns:\n                fig_score = px.histogram(df_results,\n                                         x='combined_score',\n                                         title=\"Combined Score Distribution\",\n                                         nbins=20)\n                st.plotly_chart(fig_score, use_container_width=True)\n\n            # Export option\n            if st.button(\"üì• Export Results to CSV\"):\n                csv = df_results.to_csv(index=False)\n                st.download_button(\n                    label=\"Download CSV\",\n                    data=csv,\n                    file_name=\n                    f\"screener_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\")\n        else:\n            st.warning(\n                \"No stocks found matching the criteria. Try adjusting your filters.\"\n            )\n\n    # Sector-specific screening\n    st.sidebar.header(\"üè≠ Sector Analysis\")\n\n    selected_sector = st.sidebar.selectbox(\"Analyze Sector Leaders:\", [\n        \"Technology\", \"Banking\", \"Pharmaceuticals\", \"Oil & Gas\", \"Automobiles\",\n        \"FMCG\"\n    ])\n\n    if st.sidebar.button(\"Analyze Sector\", use_container_width=True):\n        with st.spinner(f\"Analyzing {selected_sector} sector...\"):\n            try:\n                sector_leaders = screener.get_sector_leaders(selected_sector)\n\n                if sector_leaders:\n                    st.session_state.screen_results = sector_leaders\n                    st.session_state.screen_type = f\"{selected_sector} Leaders\"\n                    st.rerun()\n                else:\n                    st.sidebar.error(\n                        f\"No data available for {selected_sector} sector\")\n\n            except Exception as e:\n                st.sidebar.error(f\"Error analyzing sector: {str(e)}\")\n\n    # Screening tips\n    with st.sidebar.expander(\"üí° Screening Tips\"):\n        st.markdown(\"\"\"\n        **Momentum Screening:**\n        - Look for stocks breaking above resistance\n        - High volume confirms strong moves\n        - RSI between 50-70 shows healthy momentum\n        \n        **Value Screening:**\n        - Low P/E ratios may indicate undervaluation\n        - Check debt levels for financial stability\n        - Dividend yield adds income component\n        \n        **Growth Screening:**\n        - Revenue growth shows business expansion\n        - ROE indicates efficient capital use\n        - Consider sector trends and competition\n        \"\"\")\n\n    # Last update info\n    st.sidebar.markdown(\n        f\"**Last updated:** {datetime.now().strftime('%H:%M:%S')}\")\n\n    if st.sidebar.button(\"üîÑ Refresh Data\", use_container_width=True):\n        # Clear cache and rerun\n        if hasattr(st.session_state, 'screener'):\n            st.session_state.screener.cache.clear()\n        st.rerun()\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":22410},"pages/3_üìä_Portfolio_Tracker.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport sys\nimport os\n\n# Add the parent directory to the path to import utils\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils.portfolio import Portfolio\nfrom utils.market_data import get_real_time_price, get_stock_data\nfrom utils.fundamentals import get_fundamental_data\n\nst.set_page_config(page_title=\"Portfolio Tracker - TRADESENSEI\",\n                   page_icon=\"ü•ã\",\n                   layout=\"wide\")\n\n\ndef create_portfolio_pie_chart(sector_allocation):\n    \"\"\"Create pie chart for sector allocation\"\"\"\n    if not sector_allocation:\n        return None\n\n    sectors = list(sector_allocation.keys())\n    values = [sector_allocation[sector]['value'] for sector in sectors]\n\n    fig = go.Figure(data=go.Pie(\n        labels=sectors, values=values, hole=0.3, textinfo='label+percent'))\n\n    fig.update_layout(title=\"Portfolio Sector Allocation\", height=400)\n\n    return fig\n\n\ndef create_performance_chart(performance_history):\n    \"\"\"Create portfolio performance timeline chart\"\"\"\n    if not performance_history or 'portfolio_timeline' not in performance_history:\n        return None\n\n    timeline_data = performance_history['portfolio_timeline']\n    dates = list(timeline_data.keys())\n    values = list(timeline_data.values())\n\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Scatter(x=dates,\n                   y=values,\n                   mode='lines',\n                   name='Portfolio Value',\n                   line=dict(color='#FF6B6B', width=2)))\n\n    fig.update_layout(title=\"Portfolio Performance Timeline\",\n                      xaxis_title=\"Date\",\n                      yaxis_title=\"Portfolio Value (‚Çπ)\",\n                      height=400)\n\n    return fig\n\n\n# Add luxury styling\nst.markdown(\"\"\"\n<style>\n    .stApp {\n        background-color: #EAEOD5;\n    }\n    \n    .main-header {\n        background: linear-gradient(135deg, #000000 0%, #C6AC8E 100%);\n        padding: 1.5rem;\n        border-radius: 15px;\n        color: #EAEOD5;\n        text-align: center;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n    }\n    \n    h1, h2, h3 {\n        color: #000000;\n        font-weight: bold;\n    }\n    \n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        border: 2px solid #000000;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    }\n    \n    .stButton > button {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        color: #000000;\n        border: 2px solid #000000;\n        border-radius: 10px;\n        font-weight: bold;\n    }\n    \n    .stButton > button:hover {\n        background: linear-gradient(145deg, #000000, #C6AC8E);\n        color: #EAEOD5;\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\n\ndef main():\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 2.5rem;\">Portfolio Tracker</h1>\n        <p style=\"margin: 0.3rem 0 0 0; opacity: 0.9;\">Monitor and manage your investment portfolio</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Initialize portfolio\n    if 'portfolio' not in st.session_state:\n        st.session_state.portfolio = Portfolio()\n\n    portfolio = st.session_state.portfolio\n\n    # Tab layout\n    tab1, tab2, tab3, tab4 = st.tabs(\n        [\"üìà Overview\", \"üíº Holdings\", \"üëÅÔ∏è Watchlist\", \"‚öñÔ∏è Risk Analysis\"])\n\n    with tab1:\n        st.header(\"Portfolio Overview\")\n\n        # Get portfolio summary\n        portfolio_summary = portfolio.get_portfolio_summary()\n\n        if portfolio_summary.get('holdings_count', 0) > 0:\n            # Key metrics\n            col1, col2, col3, col4 = st.columns(4)\n\n            with col1:\n                st.metric(\"Total Value\",\n                          f\"‚Çπ{portfolio_summary['total_value']:,.2f}\",\n                          help=\"Current market value of all holdings\")\n\n            with col2:\n                st.metric(\"Total Invested\",\n                          f\"‚Çπ{portfolio_summary['total_invested']:,.2f}\",\n                          help=\"Total amount invested\")\n\n            with col3:\n                pnl = portfolio_summary['total_pnl']\n                pnl_pct = portfolio_summary['total_pnl_percent']\n                st.metric(\"Total P&L\",\n                          f\"‚Çπ{pnl:,.2f}\",\n                          delta=f\"{pnl_pct:+.2f}%\",\n                          help=\"Profit/Loss since investment\")\n\n            with col4:\n                st.metric(\"Holdings\",\n                          portfolio_summary['holdings_count'],\n                          help=\"Number of stocks in portfolio\")\n\n            # Performance charts\n            col1, col2 = st.columns(2)\n\n            with col1:\n                # Sector allocation\n                sector_allocation = portfolio.get_sector_allocation()\n                pie_chart = create_portfolio_pie_chart(sector_allocation)\n\n                if pie_chart:\n                    st.plotly_chart(pie_chart, use_container_width=True)\n                else:\n                    st.info(\"Sector allocation data not available\")\n\n            with col2:\n                # Performance history\n                performance_history = portfolio.get_portfolio_performance_history(\n                )\n                perf_chart = create_performance_chart(performance_history)\n\n                if perf_chart:\n                    st.plotly_chart(perf_chart, use_container_width=True)\n                else:\n                    st.info(\"Performance history not available\")\n\n            # Holdings performance table\n            st.subheader(\"üìã Holdings Performance\")\n\n            holdings_perf = portfolio_summary.get('holdings_performance', [])\n\n            if holdings_perf:\n                df_holdings = pd.DataFrame(holdings_perf)\n\n                # Format the dataframe for display\n                display_df = df_holdings[[\n                    'symbol', 'quantity', 'buy_price', 'current_price',\n                    'invested_amount', 'current_value', 'pnl', 'pnl_percent'\n                ]].copy()\n\n                display_df.columns = [\n                    'Symbol', 'Quantity', 'Buy Price', 'Current Price',\n                    'Invested', 'Current Value', 'P&L', 'P&L %'\n                ]\n\n                # Format numbers\n                for col in ['Buy Price', 'Current Price']:\n                    display_df[col] = display_df[col].round(2)\n\n                for col in ['Invested', 'Current Value', 'P&L']:\n                    display_df[col] = display_df[col].round(2)\n\n                display_df['P&L %'] = display_df['P&L %'].round(2)\n\n                # Color coding for P&L\n                def color_pnl(val):\n                    if val > 0:\n                        return 'color: green'\n                    elif val < 0:\n                        return 'color: red'\n                    return ''\n\n                styled_df = display_df.style.applymap(color_pnl,\n                                                      subset=['P&L', 'P&L %'])\n                st.dataframe(styled_df,\n                             use_container_width=True,\n                             hide_index=True)\n\n            # Top and worst performers\n            if portfolio_summary.get(\n                    'top_performer') and portfolio_summary.get(\n                        'worst_performer'):\n                col1, col2 = st.columns(2)\n\n                with col1:\n                    top = portfolio_summary['top_performer']\n                    st.success(\n                        f\"üèÜ **Best Performer:** {top['symbol']} (+{top['pnl_percent']:.2f}%)\"\n                    )\n\n                with col2:\n                    worst = portfolio_summary['worst_performer']\n                    st.error(\n                        f\"üìâ **Worst Performer:** {worst['symbol']} ({worst['pnl_percent']:.2f}%)\"\n                    )\n\n            # Portfolio recommendations\n            st.subheader(\"üí° AI Recommendations\")\n\n            with st.spinner(\"Generating portfolio recommendations...\"):\n                recommendations = portfolio.get_portfolio_recommendations()\n\n                if recommendations:\n                    if recommendations.get('rebalancing'):\n                        st.warning(\"‚öñÔ∏è **Rebalancing Suggestions:**\")\n                        for rec in recommendations['rebalancing']:\n                            st.write(\n                                f\"‚Ä¢ {rec['description']} (Priority: {rec.get('priority', 'Medium')})\"\n                            )\n\n                    if recommendations.get('reductions'):\n                        st.error(\"üìâ **Consider Reviewing:**\")\n                        for rec in recommendations['reductions']:\n                            st.write(f\"‚Ä¢ {rec['description']}\")\n\n                    if recommendations.get('additions'):\n                        st.info(\"üìà **Growth Opportunities:**\")\n                        for rec in recommendations['additions']:\n                            st.write(\n                                f\"‚Ä¢ {rec['description']} (Priority: {rec.get('priority', 'Medium')})\"\n                            )\n                else:\n                    st.info(\n                        \"Portfolio recommendations not available at the moment\"\n                    )\n\n        else:\n            st.info(\n                \"üìù Your portfolio is empty. Add some holdings to get started!\")\n\n            # Quick add section\n            st.subheader(\"üöÄ Quick Add Holdings\")\n\n            with st.form(\"quick_add_form\"):\n                col1, col2, col3, col4 = st.columns(4)\n\n                with col1:\n                    symbol = st.text_input(\"Stock Symbol\",\n                                           placeholder=\"e.g., RELIANCE\")\n                with col2:\n                    quantity = st.number_input(\"Quantity\",\n                                               min_value=1,\n                                               value=10)\n                with col3:\n                    buy_price = st.number_input(\"Buy Price\",\n                                                min_value=0.01,\n                                                value=100.0,\n                                                step=0.01)\n                with col4:\n                    buy_date = st.date_input(\"Buy Date\", value=datetime.now())\n\n                submitted = st.form_submit_button(\"Add to Portfolio\",\n                                                  use_container_width=True)\n\n                if submitted and symbol:\n                    success = portfolio.add_holding(\n                        symbol.upper(), quantity, buy_price,\n                        buy_date.strftime('%Y-%m-%d'))\n\n                    if success:\n                        st.success(\n                            f\"Added {quantity} shares of {symbol.upper()} to portfolio!\"\n                        )\n                        st.rerun()\n                    else:\n                        st.error(\"Failed to add holding. Please try again.\")\n\n    with tab2:\n        st.header(\"üíº Manage Holdings\")\n\n        # Add new holding\n        with st.expander(\"‚ûï Add New Holding\", expanded=False):\n            with st.form(\"add_holding_form\"):\n                col1, col2 = st.columns(2)\n\n                with col1:\n                    symbol = st.text_input(\"Stock Symbol*\",\n                                           placeholder=\"e.g., RELIANCE\")\n                    quantity = st.number_input(\"Quantity*\",\n                                               min_value=1,\n                                               value=10)\n\n                with col2:\n                    buy_price = st.number_input(\"Buy Price*\",\n                                                min_value=0.01,\n                                                value=100.0,\n                                                step=0.01)\n                    buy_date = st.date_input(\"Buy Date\", value=datetime.now())\n\n                submitted = st.form_submit_button(\"Add Holding\")\n\n                if submitted:\n                    if symbol and quantity > 0 and buy_price > 0:\n                        success = portfolio.add_holding(\n                            symbol.upper(), quantity, buy_price,\n                            buy_date.strftime('%Y-%m-%d'))\n\n                        if success:\n                            st.success(\n                                f\"Successfully added {quantity} shares of {symbol.upper()}!\"\n                            )\n                            st.rerun()\n                        else:\n                            st.error(\n                                \"Failed to add holding. Please check your inputs.\"\n                            )\n                    else:\n                        st.error(\"Please fill all required fields.\")\n\n        # Current holdings management\n        if portfolio.holdings:\n            st.subheader(\"üìã Current Holdings\")\n\n            for i, holding in enumerate(portfolio.holdings):\n                with st.expander(\n                        f\"{holding['symbol']} - {holding['quantity']} shares\"):\n                    col1, col2, col3 = st.columns(3)\n\n                    with col1:\n                        st.write(f\"**Symbol:** {holding['symbol']}\")\n                        st.write(f\"**Quantity:** {holding['quantity']}\")\n                        st.write(f\"**Buy Price:** ‚Çπ{holding['buy_price']:.2f}\")\n                        st.write(f\"**Buy Date:** {holding['buy_date']}\")\n\n                    with col2:\n                        # Get current price\n                        current_price = get_real_time_price(holding['symbol'])\n                        if current_price:\n                            pnl = (current_price -\n                                   holding['buy_price']) * holding['quantity']\n                            pnl_pct = ((current_price - holding['buy_price']) /\n                                       holding['buy_price']) * 100\n\n                            st.write(\n                                f\"**Current Price:** ‚Çπ{current_price:.2f}\")\n                            st.write(\n                                f\"**Current Value:** ‚Çπ{current_price * holding['quantity']:,.2f}\"\n                            )\n\n                            if pnl >= 0:\n                                st.success(\n                                    f\"**P&L:** +‚Çπ{pnl:,.2f} (+{pnl_pct:.2f}%)\")\n                            else:\n                                st.error(\n                                    f\"**P&L:** ‚Çπ{pnl:,.2f} ({pnl_pct:.2f}%)\")\n                        else:\n                            st.warning(\"Current price unavailable\")\n\n                    with col3:\n                        st.write(\"**Actions:**\")\n\n                        # Reduce quantity\n                        reduce_qty = st.number_input(\n                            f\"Reduce quantity\",\n                            min_value=1,\n                            max_value=holding['quantity'],\n                            value=1,\n                            key=f\"reduce_{i}\")\n\n                        col_a, col_b = st.columns(2)\n\n                        with col_a:\n                            if st.button(f\"Reduce\", key=f\"reduce_btn_{i}\"):\n                                success = portfolio.remove_holding(\n                                    holding['symbol'], reduce_qty)\n                                if success:\n                                    st.success(f\"Reduced {reduce_qty} shares\")\n                                    st.rerun()\n                                else:\n                                    st.error(\"Failed to reduce holding\")\n\n                        with col_b:\n                            if st.button(f\"Remove All\", key=f\"remove_btn_{i}\"):\n                                success = portfolio.remove_holding(\n                                    holding['symbol'])\n                                if success:\n                                    st.success(\"Holding removed completely\")\n                                    st.rerun()\n                                else:\n                                    st.error(\"Failed to remove holding\")\n        else:\n            st.info(\n                \"No holdings in portfolio. Add some holdings to get started!\")\n\n    with tab3:\n        st.header(\"üëÅÔ∏è Watchlist Management\")\n\n        # Add to watchlist\n        col1, col2 = st.columns([3, 1])\n\n        with col1:\n            new_symbol = st.text_input(\n                \"Add Stock to Watchlist\",\n                placeholder=\"Enter stock symbol (e.g., RELIANCE)\")\n\n        with col2:\n            st.write(\"\")  # Empty line for alignment\n            if st.button(\"Add to Watchlist\", use_container_width=True):\n                if new_symbol:\n                    success = portfolio.add_to_watchlist(new_symbol.upper())\n                    if success:\n                        st.success(f\"Added {new_symbol.upper()} to watchlist!\")\n                        st.rerun()\n                    else:\n                        st.warning(\n                            f\"{new_symbol.upper()} is already in watchlist!\")\n\n        # Display watchlist\n        if portfolio.watchlist:\n            st.subheader(\"üìã Your Watchlist\")\n\n            watchlist_data = portfolio.get_watchlist_data()\n\n            if watchlist_data:\n                df_watchlist = pd.DataFrame(watchlist_data)\n\n                # Format display\n                display_cols = [\n                    'symbol', 'company_name', 'current_price', 'change',\n                    'change_percent', 'sector'\n                ]\n                df_display = df_watchlist[display_cols].copy()\n                df_display.columns = [\n                    'Symbol', 'Company', 'Price', 'Change', 'Change %',\n                    'Sector'\n                ]\n\n                # Format numbers\n                df_display['Price'] = df_display['Price'].round(2)\n                df_display['Change'] = df_display['Change'].round(2)\n                df_display['Change %'] = df_display['Change %'].round(2)\n\n                # Color coding\n                def color_change(val):\n                    if val > 0:\n                        return 'color: green'\n                    elif val < 0:\n                        return 'color: red'\n                    return ''\n\n                styled_watchlist = df_display.style.applymap(\n                    color_change, subset=['Change', 'Change %'])\n                st.dataframe(styled_watchlist,\n                             use_container_width=True,\n                             hide_index=True)\n\n                # Remove from watchlist\n                st.subheader(\"üóëÔ∏è Remove from Watchlist\")\n\n                col1, col2 = st.columns([3, 1])\n\n                with col1:\n                    symbol_to_remove = st.selectbox(\"Select symbol to remove:\",\n                                                    portfolio.watchlist)\n\n                with col2:\n                    st.write(\"\")  # Alignment\n                    if st.button(\"Remove\", use_container_width=True):\n                        success = portfolio.remove_from_watchlist(\n                            symbol_to_remove)\n                        if success:\n                            st.success(\n                                f\"Removed {symbol_to_remove} from watchlist!\")\n                            st.rerun()\n                        else:\n                            st.error(\"Failed to remove from watchlist\")\n            else:\n                st.info(\"Watchlist data temporarily unavailable\")\n        else:\n            st.info(\"Your watchlist is empty. Add some stocks to monitor!\")\n\n    with tab4:\n        st.header(\"‚öñÔ∏è Risk Analysis\")\n\n        if portfolio.holdings:\n            with st.spinner(\"Analyzing portfolio risk...\"):\n                risk_analysis = portfolio.calculate_portfolio_risk()\n\n                if risk_analysis:\n                    # Risk metrics\n                    col1, col2, col3 = st.columns(3)\n\n                    concentration = risk_analysis.get('concentration_risk', {})\n\n                    with col1:\n                        st.metric(\n                            \"Top 3 Holdings %\",\n                            f\"{concentration.get('top_3_holdings_percentage', 0):.1f}%\",\n                            help=\"Percentage of portfolio in top 3 holdings\")\n\n                    with col2:\n                        st.metric(\n                            \"Max Sector Allocation\",\n                            f\"{concentration.get('max_sector_allocation', 0):.1f}%\",\n                            help=\"Highest sector concentration\")\n\n                    with col3:\n                        st.metric(\n                            \"Diversification Score\",\n                            f\"{risk_analysis.get('diversification_score', 0):.0f}/100\",\n                            help=\"Portfolio diversification rating\")\n\n                    # Risk assessment\n                    st.subheader(\"üìä Risk Assessment\")\n\n                    # Concentration risk warnings\n                    if concentration.get('top_3_holdings_percentage', 0) > 60:\n                        st.error(\n                            \"‚ö†Ô∏è **High Concentration Risk**: Top 3 holdings represent more than 60% of portfolio\"\n                        )\n                    elif concentration.get('top_3_holdings_percentage',\n                                           0) > 40:\n                        st.warning(\n                            \"‚ö†Ô∏è **Medium Concentration Risk**: Consider diversifying beyond top holdings\"\n                        )\n                    else:\n                        st.success(\n                            \"‚úÖ **Good Diversification**: Holdings are well distributed\"\n                        )\n\n                    if concentration.get('max_sector_allocation', 0) > 40:\n                        st.error(\n                            \"‚ö†Ô∏è **High Sector Risk**: Over-concentration in single sector\"\n                        )\n                    elif concentration.get('max_sector_allocation', 0) > 25:\n                        st.warning(\n                            \"‚ö†Ô∏è **Medium Sector Risk**: Consider sector diversification\"\n                        )\n                    else:\n                        st.success(\n                            \"‚úÖ **Good Sector Mix**: Well diversified across sectors\"\n                        )\n\n                    # AI Risk Analysis\n                    ai_analysis = risk_analysis.get('ai_analysis', {})\n                    if ai_analysis:\n                        st.subheader(\"ü§ñ AI Risk Insights\")\n\n                        col1, col2 = st.columns(2)\n\n                        with col1:\n                            if 'diversification_score' in ai_analysis:\n                                st.metric(\n                                    \"AI Diversification Score\",\n                                    f\"{ai_analysis['diversification_score']:.1f}/10\"\n                                )\n\n                            if 'risk_rating' in ai_analysis:\n                                st.metric(\"Risk Rating\",\n                                          f\"{ai_analysis['risk_rating']}/10\")\n\n                        with col2:\n                            if 'sector_concentration' in ai_analysis:\n                                st.write(\"**Sector Breakdown:**\")\n                                for sector, pct in ai_analysis[\n                                        'sector_concentration'].items():\n                                    st.write(f\"‚Ä¢ {sector}: {pct}%\")\n\n                        if 'recommendations' in ai_analysis:\n                            st.subheader(\"üìã Risk Mitigation Recommendations\")\n                            for rec in ai_analysis['recommendations']:\n                                st.info(f\"üí° {rec}\")\n                else:\n                    st.warning(\"Risk analysis temporarily unavailable\")\n        else:\n            st.info(\"Add holdings to your portfolio to analyze risk\")\n\n    # Sidebar actions\n    st.sidebar.header(\"üìä Portfolio Actions\")\n\n    # Export portfolio\n    if st.sidebar.button(\"üì• Export Portfolio Data\", use_container_width=True):\n        export_data = portfolio.export_portfolio_data()\n\n        if export_data:\n            # Convert to JSON for download\n            import json\n            json_data = json.dumps(export_data, indent=2, default=str)\n\n            st.sidebar.download_button(\n                label=\"Download JSON\",\n                data=json_data,\n                file_name=\n                f\"portfolio_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\",\n                mime=\"application/json\")\n\n    # Portfolio summary\n    portfolio_summary = portfolio.get_portfolio_summary()\n\n    if portfolio_summary.get('holdings_count', 0) > 0:\n        st.sidebar.metric(\"Portfolio Value\",\n                          f\"‚Çπ{portfolio_summary['total_value']:,.2f}\")\n        st.sidebar.metric(\"Total P&L\",\n                          f\"{portfolio_summary['total_pnl_percent']:+.2f}%\")\n\n    # Refresh data\n    if st.sidebar.button(\"üîÑ Refresh Data\", use_container_width=True):\n        st.rerun()\n\n    st.sidebar.markdown(\n        f\"**Last updated:** {datetime.now().strftime('%H:%M:%S')}\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":25505},"pages/4_ü§ñ_AI_Analysis.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport sys\nimport os\n\n# Add the parent directory to the path to import utils\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils.ai_analysis import (get_market_sentiment_analysis,\n                               analyze_stock_probability,\n                               generate_daily_market_summary,\n                               get_ai_stock_recommendations)\nfrom utils.portfolio import Portfolio\n\nst.set_page_config(page_title=\"AI Analysis - TRADESENSEI\",\n                   page_icon=\"ü•ã\",\n                   layout=\"wide\")\n\n\ndef create_probability_gauge(probability, title):\n    \"\"\"Create a probability gauge chart\"\"\"\n    fig = go.Figure(\n        go.Indicator(mode=\"gauge+number+delta\",\n                     value=probability * 100,\n                     domain={\n                         'x': [0, 1],\n                         'y': [0, 1]\n                     },\n                     title={'text': title},\n                     delta={'reference': 50},\n                     gauge={\n                         'axis': {\n                             'range': [None, 100]\n                         },\n                         'bar': {\n                             'color': \"darkblue\"\n                         },\n                         'steps': [{\n                             'range': [0, 25],\n                             'color': \"lightgray\"\n                         }, {\n                             'range': [25, 50],\n                             'color': \"gray\"\n                         }, {\n                             'range': [50, 75],\n                             'color': \"lightgreen\"\n                         }, {\n                             'range': [75, 100],\n                             'color': \"green\"\n                         }],\n                         'threshold': {\n                             'line': {\n                                 'color': \"red\",\n                                 'width': 4\n                             },\n                             'thickness': 0.75,\n                             'value': 90\n                         }\n                     }))\n\n    fig.update_layout(height=300)\n    return fig\n\n\ndef create_sentiment_chart(sentiment_data):\n    \"\"\"Create sentiment analysis visualization\"\"\"\n    if not sentiment_data:\n        return None\n\n    # Create a simple sentiment indicator\n    sentiment_score = sentiment_data.get('probability', 0.5)\n    sentiment_label = sentiment_data.get('sentiment', 'neutral')\n\n    colors = {'bullish': 'green', 'bearish': 'red', 'neutral': 'gray'}\n    color = colors.get(sentiment_label, 'gray')\n\n    fig = go.Figure(data=go.Bar(x=[sentiment_label.title()],\n                                y=[sentiment_score * 100],\n                                marker_color=color))\n\n    fig.update_layout(title=\"Market Sentiment Score\",\n                      yaxis_title=\"Confidence %\",\n                      height=300)\n\n    return fig\n\n\n# Add luxury styling\nst.markdown(\"\"\"\n<style>\n    .stApp {\n        background-color: #EAEOD5;\n    }\n    \n    .main-header {\n        background: linear-gradient(135deg, #000000 0%, #C6AC8E 100%);\n        padding: 1.5rem;\n        border-radius: 15px;\n        color: #EAEOD5;\n        text-align: center;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n    }\n    \n    h1, h2, h3 {\n        color: #000000;\n        font-weight: bold;\n    }\n    \n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        border: 2px solid #000000;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    }\n    \n    .stButton > button {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        color: #000000;\n        border: 2px solid #000000;\n        border-radius: 10px;\n        font-weight: bold;\n    }\n    \n    .stButton > button:hover {\n        background: linear-gradient(145deg, #000000, #C6AC8E);\n        color: #EAEOD5;\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\n\ndef main():\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 2.5rem;\"> DRAVYUM AI </h1>\n        <p style=\"margin: 0.3rem 0 0 0; opacity: 0.9;\">Advanced artificial intelligence insights for Indian markets</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Tab layout\n    tab1, tab2, tab3, tab4 = st.tabs([\n        \"üìä Market Sentiment\", \"üéØ Stock Analysis\", \"üí° Recommendations\",\n        \"üîÆ Predictions\"\n    ])\n\n    with tab1:\n        st.header(\"üìä Market Sentiment Analysis\")\n\n        col1, col2 = st.columns([1, 1])\n\n        with col1:\n            if st.button(\"üîÑ Generate Fresh Analysis\",\n                         use_container_width=True):\n                with st.spinner(\"Analyzing market sentiment using AI...\"):\n                    try:\n                        sentiment_analysis = get_market_sentiment_analysis()\n                        if sentiment_analysis:\n                            st.session_state.sentiment_data = sentiment_analysis\n                            st.success(\"Analysis complete!\")\n                        else:\n                            st.error(\"Failed to generate sentiment analysis\")\n                    except Exception as e:\n                        st.error(f\"Error: {str(e)}\")\n\n        with col2:\n            if st.button(\"üìÑ Generate Market Summary\",\n                         use_container_width=True):\n                with st.spinner(\"Generating comprehensive market summary...\"):\n                    try:\n                        market_summary = generate_daily_market_summary()\n                        if market_summary:\n                            st.session_state.market_summary = market_summary\n                            st.success(\"Summary generated!\")\n                        else:\n                            st.error(\"Failed to generate market summary\")\n                    except Exception as e:\n                        st.error(f\"Error: {str(e)}\")\n\n        # Display sentiment analysis\n        if hasattr(st.session_state,\n                   'sentiment_data') and st.session_state.sentiment_data:\n            sentiment_data = st.session_state.sentiment_data\n\n            # Key metrics\n            col1, col2, col3, col4 = st.columns(4)\n\n            with col1:\n                sentiment = sentiment_data.get('sentiment', 'neutral').title()\n                sentiment_emoji = {\n                    'Bullish': 'üìà',\n                    'Bearish': 'üìâ',\n                    'Neutral': '‚û°Ô∏è'\n                }\n                st.metric(\n                    \"Market Sentiment\",\n                    f\"{sentiment_emoji.get(sentiment, '‚û°Ô∏è')} {sentiment}\",\n                    help=\"AI-assessed market direction\")\n\n            with col2:\n                probability = sentiment_data.get('probability', 0) * 100\n                st.metric(\"Confidence Score\",\n                          f\"{probability:.1f}%\",\n                          help=\"AI confidence in the assessment\")\n\n            with col3:\n                direction = sentiment_data.get('direction', 'sideways').title()\n                st.metric(\"Expected Movement\",\n                          direction,\n                          help=\"Predicted market direction\")\n\n            with col4:\n                duration = sentiment_data.get('duration', 'N/A')\n                st.metric(\"Time Horizon\",\n                          duration,\n                          help=\"Expected duration of trend\")\n\n            # Detailed analysis\n            col1, col2 = st.columns(2)\n\n            with col1:\n                # Sentiment gauge\n                prob_gauge = create_probability_gauge(\n                    sentiment_data.get('probability', 0.5),\n                    \"Market Sentiment Probability\")\n                st.plotly_chart(prob_gauge, use_container_width=True)\n\n            with col2:\n                # Risk level indicator\n                risk_level = sentiment_data.get('risk_level', 'medium')\n                risk_colors = {\n                    'low': 'green',\n                    'medium': 'orange',\n                    'high': 'red'\n                }\n                risk_color = risk_colors.get(risk_level, 'gray')\n\n                st.markdown(\"### Risk Assessment\")\n                st.markdown(\n                    f\"**Risk Level:** :{risk_color}[{risk_level.upper()}]\")\n\n                # Key factors\n                key_factors = sentiment_data.get('key_factors', [])\n                if key_factors:\n                    st.markdown(\"**Key Influencing Factors:**\")\n                    for factor in key_factors:\n                        st.write(f\"‚Ä¢ {factor}\")\n\n            # Detailed analysis text\n            st.subheader(\"üîç Detailed AI Analysis\")\n            analysis_text = sentiment_data.get('analysis',\n                                               'Analysis not available')\n            st.write(analysis_text)\n\n        # Display market summary\n        if hasattr(st.session_state,\n                   'market_summary') and st.session_state.market_summary:\n            st.subheader(\"üì∞ AI-Generated Market Summary\")\n\n            summary_text = st.session_state.market_summary\n            st.markdown(summary_text)\n\n        # Historical sentiment (simulated for demonstration)\n        st.subheader(\"üìà Sentiment Trend\")\n\n        # Create sample historical sentiment data\n        dates = pd.date_range(start=datetime.now() - timedelta(days=30),\n                              end=datetime.now(),\n                              freq='D')\n        sentiment_scores = [0.3 + 0.4 * (i % 7) / 6 for i in range(len(dates))]\n\n        sentiment_df = pd.DataFrame({\n            'Date': dates,\n            'Sentiment_Score': sentiment_scores\n        })\n\n        fig = px.line(sentiment_df,\n                      x='Date',\n                      y='Sentiment_Score',\n                      title=\"30-Day Sentiment Trend\",\n                      labels={'Sentiment_Score': 'Bullish Sentiment (0-1)'})\n        fig.add_hline(y=0.5,\n                      line_dash=\"dash\",\n                      line_color=\"gray\",\n                      annotation_text=\"Neutral Line\")\n\n        st.plotly_chart(fig, use_container_width=True)\n\n    with tab2:\n        st.header(\"üéØ Individual Stock Analysis\")\n\n        col1, col2 = st.columns([2, 1])\n\n        with col1:\n            symbol_input = st.text_input(\"Enter Stock Symbol\",\n                                         placeholder=\"e.g., RELIANCE\",\n                                         value=\"RELIANCE\")\n\n        with col2:\n            timeframe = st.selectbox(\"Analysis Timeframe\",\n                                     [\"1 week\", \"2 weeks\", \"1 month\"])\n\n        if st.button(\"üîç Analyze Stock\", use_container_width=True):\n            if symbol_input:\n                with st.spinner(f\"Analyzing {symbol_input} using AI...\"):\n                    try:\n                        stock_analysis = analyze_stock_probability(\n                            symbol_input, timeframe)\n                        if stock_analysis:\n                            st.session_state.stock_analysis = stock_analysis\n                            st.success(\"Stock analysis complete!\")\n                        else:\n                            st.error(\"Failed to analyze stock\")\n                    except Exception as e:\n                        st.error(f\"Error analyzing stock: {str(e)}\")\n\n        # Display stock analysis\n        if hasattr(st.session_state,\n                   'stock_analysis') and st.session_state.stock_analysis:\n            analysis = st.session_state.stock_analysis\n\n            st.subheader(\n                f\"üìä Analysis Results: {analysis.get('symbol', 'Unknown')}\")\n\n            # Probability metrics\n            col1, col2, col3 = st.columns(3)\n\n            with col1:\n                upward_prob = analysis.get('upward_probability', 0) * 100\n                st.metric(\"Upward Probability\",\n                          f\"{upward_prob:.1f}%\",\n                          delta=\"Bullish Signal\")\n\n            with col2:\n                downward_prob = analysis.get('downward_probability', 0) * 100\n                st.metric(\"Downward Probability\",\n                          f\"{downward_prob:.1f}%\",\n                          delta=\"Bearish Signal\")\n\n            with col3:\n                confidence = analysis.get('confidence', 0) * 100\n                st.metric(\"Analysis Confidence\", f\"{confidence:.1f}%\")\n\n            # Price range prediction\n            price_range = analysis.get('expected_price_range', {})\n            if price_range:\n                col1, col2 = st.columns(2)\n\n                with col1:\n                    st.metric(\"Expected Low\",\n                              f\"‚Çπ{price_range.get('low', 0):.2f}\")\n\n                with col2:\n                    st.metric(\"Expected High\",\n                              f\"‚Çπ{price_range.get('high', 0):.2f}\")\n\n            # Recommendation\n            recommendation = analysis.get('recommendation', 'hold').upper()\n            rec_colors = {'BUY': 'green', 'SELL': 'red', 'HOLD': 'orange'}\n            rec_color = rec_colors.get(recommendation, 'gray')\n\n            st.markdown(\n                f\"### AI Recommendation: :{rec_color}[{recommendation}]\")\n\n            # Technical signals\n            signals = analysis.get('technical_signals', [])\n            if signals:\n                st.subheader(\"üìà Key Technical Signals\")\n                for signal in signals:\n                    st.write(f\"‚Ä¢ {signal}\")\n\n            # Probability visualization\n            col1, col2 = st.columns(2)\n\n            with col1:\n                # Probability pie chart\n                prob_data = {\n                    'Direction': ['Upward', 'Downward'],\n                    'Probability': [\n                        analysis.get('upward_probability', 0),\n                        analysis.get('downward_probability', 0)\n                    ]\n                }\n\n                fig_prob = px.pie(\n                    values=prob_data['Probability'],\n                    names=prob_data['Direction'],\n                    title=f\"Price Movement Probabilities - {timeframe}\",\n                    color_discrete_map={\n                        'Upward': 'green',\n                        'Downward': 'red'\n                    })\n                st.plotly_chart(fig_prob, use_container_width=True)\n\n            with col2:\n                # Confidence gauge\n                conf_gauge = create_probability_gauge(\n                    analysis.get('confidence', 0.5), \"Analysis Confidence\")\n                st.plotly_chart(conf_gauge, use_container_width=True)\n\n    with tab3:\n        st.header(\"üí° AI Stock Recommendations\")\n\n        st.markdown(\n            \"Get personalized stock recommendations based on your criteria\")\n\n        # Recommendation criteria\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.subheader(\"üìã Set Your Criteria\")\n\n            market_cap = st.selectbox(\"Market Cap Preference\",\n                                      [\"large\", \"mid\", \"small\", \"any\"])\n            risk_level = st.selectbox(\"Risk Tolerance\",\n                                      [\"low\", \"medium\", \"high\"])\n\n        with col2:\n            sector = st.selectbox(\"Sector Preference\", [\n                \"any\", \"Technology\", \"Banking\", \"Pharmaceuticals\", \"Oil & Gas\",\n                \"Automobiles\", \"FMCG\"\n            ])\n            time_horizon = st.selectbox(\n                \"Investment Horizon\",\n                [\"short-term\", \"medium-term\", \"long-term\"])\n\n        if st.button(\"üéØ Get AI Recommendations\", use_container_width=True):\n            criteria = {\n                'market_cap': market_cap,\n                'sector': sector,\n                'risk_level': risk_level,\n                'time_horizon': time_horizon\n            }\n\n            with st.spinner(\"Generating personalized recommendations...\"):\n                try:\n                    recommendations = get_ai_stock_recommendations(criteria)\n                    if recommendations:\n                        st.session_state.ai_recommendations = recommendations\n                        st.success(\"Recommendations generated!\")\n                    else:\n                        st.error(\"Failed to generate recommendations\")\n                except Exception as e:\n                    st.error(f\"Error: {str(e)}\")\n\n        # Display recommendations\n        if hasattr(\n                st.session_state,\n                'ai_recommendations') and st.session_state.ai_recommendations:\n            recommendations = st.session_state.ai_recommendations\n\n            st.subheader(\"üéØ AI-Curated Stock Picks\")\n\n            for i, rec in enumerate(recommendations):\n                with st.expander(\n                        f\"#{i+1} {rec.get('symbol', 'Unknown')} - {rec.get('company_name', 'N/A')}\"\n                ):\n                    col1, col2, col3 = st.columns(3)\n\n                    with col1:\n                        st.metric(\"Target Price\",\n                                  f\"‚Çπ{rec.get('target_price', 0):,.2f}\")\n                        st.metric(\"Upside Potential\",\n                                  f\"{rec.get('upside_potential', 0):+.1f}%\")\n\n                    with col2:\n                        risk_rating = rec.get('risk_rating', 'medium')\n                        risk_emoji = {'low': 'üü¢', 'medium': 'üü°', 'high': 'üî¥'}\n                        st.write(\n                            f\"**Risk Rating:** {risk_emoji.get(risk_rating, 'üü°')} {risk_rating.title()}\"\n                        )\n\n                        st.write(f\"**Symbol:** {rec.get('symbol', 'N/A')}\")\n\n                    with col3:\n                        st.write(\"**Investment Rationale:**\")\n                        rationale = rec.get('rationale',\n                                            'Rationale not available')\n                        st.write(rationale)\n\n        # Portfolio-based recommendations\n        st.subheader(\"üìä Portfolio Enhancement Suggestions\")\n\n        if st.button(\"üîç Analyze My Portfolio for Recommendations\"):\n            portfolio = Portfolio()\n\n            if portfolio.holdings:\n                with st.spinner(\n                        \"Analyzing your portfolio for improvement opportunities...\"\n                ):\n                    try:\n                        portfolio_recommendations = portfolio.get_portfolio_recommendations(\n                        )\n\n                        if portfolio_recommendations:\n                            st.write(\"**Based on your current portfolio:**\")\n\n                            # Rebalancing suggestions\n                            if portfolio_recommendations.get('rebalancing'):\n                                st.warning(\"‚öñÔ∏è **Rebalancing Opportunities:**\")\n                                for rec in portfolio_recommendations[\n                                        'rebalancing'][:3]:\n                                    st.write(f\"‚Ä¢ {rec['description']}\")\n\n                            # Addition suggestions\n                            if portfolio_recommendations.get('additions'):\n                                st.info(\"üìà **Growth Opportunities:**\")\n                                for rec in portfolio_recommendations[\n                                        'additions'][:3]:\n                                    st.write(f\"‚Ä¢ {rec['description']}\")\n                        else:\n                            st.info(\"Your portfolio looks well-balanced!\")\n\n                    except Exception as e:\n                        st.error(f\"Error analyzing portfolio: {str(e)}\")\n            else:\n                st.info(\n                    \"Add holdings to your portfolio to get personalized recommendations\"\n                )\n\n    with tab4:\n        st.header(\"üîÆ Market Predictions & Forecasts\")\n\n        st.markdown(\"Advanced AI predictions for market movements\")\n\n        # NIFTY prediction\n        st.subheader(\"üìä NIFTY 50 Forecast\")\n\n        prediction_timeframe = st.selectbox(\"Prediction Timeframe\",\n                                            [\"1 week\", \"2 weeks\", \"1 month\"])\n\n        if st.button(\"üîÆ Generate NIFTY Prediction\"):\n            with st.spinner(\"Generating NIFTY 50 predictions...\"):\n                try:\n                    nifty_prediction = analyze_stock_probability(\n                        \"NIFTY\", prediction_timeframe)\n                    if nifty_prediction:\n                        st.session_state.nifty_prediction = nifty_prediction\n                        st.success(\"Prediction generated!\")\n                except Exception as e:\n                    st.error(f\"Error generating prediction: {str(e)}\")\n\n        # Display NIFTY prediction\n        if hasattr(st.session_state,\n                   'nifty_prediction') and st.session_state.nifty_prediction:\n            pred = st.session_state.nifty_prediction\n\n            col1, col2, col3 = st.columns(3)\n\n            with col1:\n                upward_prob = pred.get('upward_probability', 0) * 100\n                st.metric(\"Bull Probability\", f\"{upward_prob:.1f}%\")\n\n            with col2:\n                downward_prob = pred.get('downward_probability', 0) * 100\n                st.metric(\"Bear Probability\", f\"{downward_prob:.1f}%\")\n\n            with col3:\n                confidence = pred.get('confidence', 0) * 100\n                st.metric(\"Prediction Confidence\", f\"{confidence:.1f}%\")\n\n            # Expected range\n            price_range = pred.get('expected_price_range', {})\n            if price_range:\n                st.subheader(\n                    f\"üìä Expected NIFTY Range ({prediction_timeframe})\")\n                col1, col2 = st.columns(2)\n\n                with col1:\n                    st.metric(\"Expected Low\",\n                              f\"{price_range.get('low', 0):,.0f}\")\n                with col2:\n                    st.metric(\"Expected High\",\n                              f\"{price_range.get('high', 0):,.0f}\")\n\n        # Sector predictions\n        st.subheader(\"üè≠ Sector Outlook\")\n\n        sectors = [\n            \"Banking\", \"Technology\", \"Pharmaceuticals\", \"Automobiles\", \"FMCG\"\n        ]\n\n        # Create sample sector predictions (in production, this would use real AI)\n        sector_predictions = []\n        for sector in sectors:\n            # Simulate predictions\n            import random\n            outlook = random.choice([\"Bullish\", \"Bearish\", \"Neutral\"])\n            confidence = random.uniform(0.6, 0.9)\n\n            sector_predictions.append({\n                'Sector':\n                sector,\n                'Outlook':\n                outlook,\n                'Confidence':\n                f\"{confidence*100:.0f}%\",\n                'Rating':\n                random.choice([\"Buy\", \"Hold\", \"Sell\"])\n            })\n\n        df_sectors = pd.DataFrame(sector_predictions)\n\n        # Color coding\n        def color_outlook(val):\n            if val == 'Bullish':\n                return 'color: green'\n            elif val == 'Bearish':\n                return 'color: red'\n            return 'color: gray'\n\n        styled_sectors = df_sectors.style.applymap(color_outlook,\n                                                   subset=['Outlook'])\n        st.dataframe(styled_sectors, use_container_width=True, hide_index=True)\n\n        # Market timing analysis\n        st.subheader(\"‚è∞ Market Timing Analysis\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.info(\"üìà **Optimal Entry Points:**\")\n            st.write(\n                \"‚Ä¢ Market corrections of 2-3% provide good entry opportunities\"\n            )\n            st.write(\"‚Ä¢ Mid-month periods typically show lower volatility\")\n            st.write(\n                \"‚Ä¢ Post-earnings season often presents value opportunities\")\n\n        with col2:\n            st.warning(\"‚ö†Ô∏è **Risk Periods:**\")\n            st.write(\"‚Ä¢ First week of month typically shows higher volatility\")\n            st.write(\"‚Ä¢ Global event impacts can cause temporary disruptions\")\n            st.write(\"‚Ä¢ End of quarter profit booking may increase volatility\")\n\n    # Sidebar information\n    st.sidebar.header(\"ü§ñ AI Analysis Info\")\n\n    st.sidebar.info(\"\"\"\n    **AI Model Information:**\n    - Powered by GPT-4o\n    - Analyzes real-time market data\n    - Incorporates technical & fundamental factors\n    - Provides probability-based predictions\n    \"\"\")\n\n    # Disclaimer\n    st.sidebar.warning(\"\"\"\n    **Disclaimer:**\n    AI predictions are for informational purposes only. \n    Always conduct your own research before making investment decisions.\n    Past performance does not guarantee future results.\n    \"\"\")\n\n    # API status\n    st.sidebar.subheader(\"üì° System Status\")\n    st.sidebar.success(\"üü¢ AI Engine: Online\")\n    st.sidebar.success(\"üü¢ Market Data: Live\")\n\n    st.sidebar.markdown(\n        f\"**Last updated:** {datetime.now().strftime('%H:%M:%S')}\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":25160},"pages/5_üìß_Reports_Settings.py":{"content":"import streamlit as st\nimport json\nimport os\nfrom datetime import datetime, time, timedelta\nimport sys\n\n# Add the parent directory to the path to import utils\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom utils.scheduler import get_scheduler_instance\nfrom utils.notifications import test_notification_setup, save_report_notification, save_alert_notification\nfrom utils.ai_analysis import generate_daily_market_summary\nfrom utils.market_data import get_top_gainers_losers, get_nifty_data\n\nst.set_page_config(page_title=\"Reports & Settings - TRADESENSEI\",\n                   page_icon=\"ü•ã\",\n                   layout=\"wide\")\n\n\ndef save_settings(settings):\n    \"\"\"Save settings to file\"\"\"\n    try:\n        with open('app_settings.json', 'w') as f:\n            json.dump(settings, f, indent=2)\n        return True\n    except Exception as e:\n        st.error(f\"Error saving settings: {e}\")\n        return False\n\n\ndef load_settings():\n    \"\"\"Load settings from file\"\"\"\n    try:\n        if os.path.exists('app_settings.json'):\n            with open('app_settings.json', 'r') as f:\n                return json.load(f)\n        else:\n            # Return default settings\n            return {\n                'email_notifications': True,\n                'whatsapp_notifications': True,\n                'daily_report_time': '08:00',\n                'recipient_email': 'user@example.com',\n                'recipient_phone': '+919999999999',\n                'report_frequency': 'daily',\n                'include_ai_insights': True,\n                'include_top_movers': True,\n                'include_portfolio_summary': True,\n                'alert_thresholds': {\n                    'nifty_change': 2.0,\n                    'stock_change': 5.0,\n                    'volume_spike': 2.0\n                },\n                'watchlist_alerts': True,\n                'portfolio_alerts': True\n            }\n    except Exception as e:\n        st.error(f\"Error loading settings: {e}\")\n        return {}\n\n\n# Add luxury styling\nst.markdown(\"\"\"\n<style>\n    .stApp {\n        background-color: #EAEOD5;\n    }\n    \n    .main-header {\n        background: linear-gradient(135deg, #000000 0%, #C6AC8E 100%);\n        padding: 1.5rem;\n        border-radius: 15px;\n        color: #EAEOD5;\n        text-align: center;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n    }\n    \n    h1, h2, h3 {\n        color: #000000;\n        font-weight: bold;\n    }\n    \n    [data-testid=\"metric-container\"] {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        border: 2px solid #000000;\n        padding: 1rem;\n        border-radius: 15px;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n    }\n    \n    .stButton > button {\n        background: linear-gradient(145deg, #C6AC8E, #EAEOD5);\n        color: #000000;\n        border: 2px solid #000000;\n        border-radius: 10px;\n        font-weight: bold;\n    }\n    \n    .stButton > button:hover {\n        background: linear-gradient(145deg, #000000, #C6AC8E);\n        color: #EAEOD5;\n    }\n</style>\n\"\"\",\n            unsafe_allow_html=True)\n\n\ndef main():\n    st.markdown(\"\"\"\n    <div class=\"main-header\">\n        <h1 style=\"margin: 0; font-size: 2.5rem;\">Reports & Settings</h1>\n        <p style=\"margin: 0.3rem 0 0 0; opacity: 0.9;\">Configure automated reports and alert preferences</p>\n    </div>\n    \"\"\",\n                unsafe_allow_html=True)\n\n    # Load current settings\n    if 'app_settings' not in st.session_state:\n        st.session_state.app_settings = load_settings()\n\n    settings = st.session_state.app_settings\n\n    # Tab layout\n    tab1, tab2, tab3, tab4 = st.tabs(\n        [\"üìä Report Settings\", \"üîî Notifications\", \"‚ö° Alerts\", \"üß™ Testing\"])\n\n    with tab1:\n        st.header(\"üìä Daily Report Configuration\")\n\n        # Report schedule\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.subheader(\"üìÖ Schedule Settings\")\n\n            report_frequency = st.selectbox(\n                \"Report Frequency\", [\"daily\", \"weekdays\", \"weekly\"],\n                index=[\"daily\", \"weekdays\", \"weekly\"\n                       ].index(settings.get('report_frequency', 'daily')))\n            settings['report_frequency'] = report_frequency\n\n            # Time selection\n            report_time = st.time_input(\"Daily Report Time\",\n                                        value=time.fromisoformat(\n                                            settings.get(\n                                                'daily_report_time', '08:00')))\n            settings['daily_report_time'] = report_time.strftime('%H:%M')\n\n            # Timezone info\n            st.info(\"üìç All times are in Indian Standard Time (IST)\")\n\n        with col2:\n            st.subheader(\"üìß Delivery Settings\")\n\n            recipient_email = st.text_input(\n                \"Email Address\",\n                value=settings.get('recipient_email', 'user@example.com'),\n                help=\"Email address for daily reports\")\n            settings['recipient_email'] = recipient_email\n\n            recipient_phone = st.text_input(\n                \"WhatsApp Number\",\n                value=settings.get('recipient_phone', '+919999999999'),\n                help=\"Phone number with country code (e.g., +919999999999)\")\n            settings['recipient_phone'] = recipient_phone\n\n        # Report content\n        st.subheader(\"üìã Report Content\")\n\n        col1, col2, col3 = st.columns(3)\n\n        with col1:\n            include_ai_insights = st.checkbox(\n                \"ü§ñ AI Market Insights\",\n                value=settings.get('include_ai_insights', True),\n                help=\"Include AI-generated market analysis\")\n            settings['include_ai_insights'] = include_ai_insights\n\n        with col2:\n            include_top_movers = st.checkbox(\n                \"üî• Top Gainers/Losers\",\n                value=settings.get('include_top_movers', True),\n                help=\"Include top performing stocks\")\n            settings['include_top_movers'] = include_top_movers\n\n        with col3:\n            include_portfolio = st.checkbox(\n                \"üíº Portfolio Summary\",\n                value=settings.get('include_portfolio_summary', True),\n                help=\"Include your portfolio performance\")\n            settings['include_portfolio_summary'] = include_portfolio\n\n        # Additional options\n        st.subheader(\"‚öôÔ∏è Advanced Options\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            include_breakouts = st.checkbox(\n                \"üöÄ Breakout Analysis\",\n                value=settings.get('include_breakouts', True),\n                help=\"Include stocks breaking technical levels\")\n            settings['include_breakouts'] = include_breakouts\n\n            include_sector_analysis = st.checkbox(\n                \"üè≠ Sector Performance\",\n                value=settings.get('include_sector_analysis', True),\n                help=\"Include sectoral performance overview\")\n            settings['include_sector_analysis'] = include_sector_analysis\n\n        with col2:\n            include_technical_levels = st.checkbox(\n                \"üìà Key Technical Levels\",\n                value=settings.get('include_technical_levels', True),\n                help=\"Include support/resistance levels\")\n            settings['include_technical_levels'] = include_technical_levels\n\n            include_news_sentiment = st.checkbox(\n                \"üì∞ News Sentiment\",\n                value=settings.get('include_news_sentiment', False),\n                help=\"Include news-based market sentiment\")\n            settings['include_news_sentiment'] = include_news_sentiment\n\n    with tab2:\n        st.header(\"üîî Notification Preferences\")\n\n        # Notification methods\n        col1, col2 = st.columns(2)\n\n        with col1:\n            st.subheader(\"üìß Email Notifications\")\n\n            email_notifications = st.checkbox(\"Enable Email Notifications\",\n                                              value=settings.get(\n                                                  'email_notifications', True))\n            settings['email_notifications'] = email_notifications\n\n            if email_notifications:\n                st.success(\"‚úÖ Email notifications enabled\")\n\n                email_types = st.multiselect(\n                    \"Email Notification Types\", [\n                        \"Daily Reports\", \"Portfolio Alerts\", \"Market Alerts\",\n                        \"Breakout Alerts\"\n                    ],\n                    default=settings.get('email_types',\n                                         [\"Daily Reports\", \"Market Alerts\"]))\n                settings['email_types'] = email_types\n            else:\n                st.warning(\"‚ö†Ô∏è Email notifications disabled\")\n\n        with col2:\n            st.subheader(\"üí¨ WhatsApp Notifications\")\n\n            whatsapp_notifications = st.checkbox(\n                \"Enable WhatsApp Notifications\",\n                value=settings.get('whatsapp_notifications', True))\n            settings['whatsapp_notifications'] = whatsapp_notifications\n\n            if whatsapp_notifications:\n                st.success(\"‚úÖ WhatsApp notifications enabled\")\n\n                whatsapp_types = st.multiselect(\n                    \"WhatsApp Notification Types\", [\n                        \"Market Summary\", \"Critical Alerts\",\n                        \"Portfolio Updates\", \"Quick Insights\"\n                    ],\n                    default=settings.get(\n                        'whatsapp_types',\n                        [\"Market Summary\", \"Critical Alerts\"]))\n                settings['whatsapp_types'] = whatsapp_types\n            else:\n                st.warning(\"‚ö†Ô∏è WhatsApp notifications disabled\")\n\n        # Notification timing\n        st.subheader(\"‚è∞ Notification Timing\")\n\n        col1, col2, col3 = st.columns(3)\n\n        with col1:\n            market_open_alert = st.checkbox(\n                \"Market Opening Alert\",\n                value=settings.get('market_open_alert', True),\n                help=\"Get notified when market opens\")\n            settings['market_open_alert'] = market_open_alert\n\n        with col2:\n            market_close_alert = st.checkbox(\n                \"Market Closing Summary\",\n                value=settings.get('market_close_alert', True),\n                help=\"Get end-of-day market summary\")\n            settings['market_close_alert'] = market_close_alert\n\n        with col3:\n            midday_update = st.checkbox(\"Mid-day Update\",\n                                        value=settings.get(\n                                            'midday_update', False),\n                                        help=\"Get market update at lunch time\")\n            settings['midday_update'] = midday_update\n\n        # Quiet hours\n        st.subheader(\"üîá Do Not Disturb\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            quiet_start = st.time_input(\n                \"Quiet Hours Start\",\n                value=time.fromisoformat(settings.get('quiet_start', '22:00')))\n            settings['quiet_start'] = quiet_start.strftime('%H:%M')\n\n        with col2:\n            quiet_end = st.time_input(\"Quiet Hours End\",\n                                      value=time.fromisoformat(\n                                          settings.get('quiet_end', '07:00')))\n            settings['quiet_end'] = quiet_end.strftime('%H:%M')\n\n        st.info(\n            f\"üîá No notifications will be sent between {quiet_start} and {quiet_end}\"\n        )\n\n    with tab3:\n        st.header(\"‚ö° Alert Configuration\")\n\n        # Price change alerts\n        st.subheader(\"üìä Price Change Alerts\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            nifty_threshold = st.number_input(\n                \"NIFTY Change Threshold (%)\",\n                min_value=0.5,\n                max_value=10.0,\n                value=settings.get('alert_thresholds',\n                                   {}).get('nifty_change', 2.0),\n                step=0.5,\n                help=\"Alert when NIFTY moves by this percentage\")\n\n            stock_threshold = st.number_input(\n                \"Individual Stock Threshold (%)\",\n                min_value=1.0,\n                max_value=20.0,\n                value=settings.get('alert_thresholds',\n                                   {}).get('stock_change', 5.0),\n                step=0.5,\n                help=\"Alert for individual stock movements\")\n\n        with col2:\n            volume_threshold = st.number_input(\n                \"Volume Spike Threshold (x)\",\n                min_value=1.5,\n                max_value=10.0,\n                value=settings.get('alert_thresholds',\n                                   {}).get('volume_spike', 2.0),\n                step=0.5,\n                help=\"Alert when volume is X times the average\")\n\n            breakout_sensitivity = st.selectbox(\n                \"Breakout Alert Sensitivity\", [\"Low\", \"Medium\", \"High\"],\n                index=[\"Low\", \"Medium\", \"High\"\n                       ].index(settings.get('breakout_sensitivity', 'Medium')))\n\n        # Update alert thresholds\n        if 'alert_thresholds' not in settings:\n            settings['alert_thresholds'] = {}\n\n        settings['alert_thresholds']['nifty_change'] = nifty_threshold\n        settings['alert_thresholds']['stock_change'] = stock_threshold\n        settings['alert_thresholds']['volume_spike'] = volume_threshold\n        settings['breakout_sensitivity'] = breakout_sensitivity\n\n        # Portfolio alerts\n        st.subheader(\"üíº Portfolio Alerts\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            portfolio_alerts = st.checkbox(\n                \"Enable Portfolio Alerts\",\n                value=settings.get('portfolio_alerts', True),\n                help=\"Get alerts about your portfolio holdings\")\n            settings['portfolio_alerts'] = portfolio_alerts\n\n            if portfolio_alerts:\n                portfolio_threshold = st.number_input(\n                    \"Portfolio Alert Threshold (%)\",\n                    min_value=1.0,\n                    max_value=10.0,\n                    value=settings.get('portfolio_threshold', 3.0),\n                    step=0.5,\n                    help=\"Alert when portfolio moves by this percentage\")\n                settings['portfolio_threshold'] = portfolio_threshold\n\n        with col2:\n            watchlist_alerts = st.checkbox(\n                \"Enable Watchlist Alerts\",\n                value=settings.get('watchlist_alerts', True),\n                help=\"Get alerts about watchlist stocks\")\n            settings['watchlist_alerts'] = watchlist_alerts\n\n            if watchlist_alerts:\n                watchlist_threshold = st.number_input(\n                    \"Watchlist Alert Threshold (%)\",\n                    min_value=1.0,\n                    max_value=15.0,\n                    value=settings.get('watchlist_threshold', 5.0),\n                    step=0.5,\n                    help=\"Alert when watchlist stocks move by this percentage\")\n                settings['watchlist_threshold'] = watchlist_threshold\n\n        # Custom alerts\n        st.subheader(\"Custom Price Alerts\")\n\n        if 'custom_alerts' not in settings:\n            settings['custom_alerts'] = []\n\n        # Add new custom alert\n        with st.expander(\"‚ûï Add Custom Alert\"):\n            col1, col2, col3, col4 = st.columns(4)\n\n            with col1:\n                alert_symbol = st.text_input(\"Stock Symbol\",\n                                             placeholder=\"e.g., RELIANCE\")\n\n            with col2:\n                alert_condition = st.selectbox(\"Condition\", [\"Above\", \"Below\"])\n\n            with col3:\n                alert_price = st.number_input(\"Price\",\n                                              min_value=0.01,\n                                              value=100.0)\n\n            with col4:\n                st.write(\"\")  # Spacing\n                if st.button(\"Add Alert\"):\n                    if alert_symbol and alert_price > 0:\n                        new_alert = {\n                            'symbol': alert_symbol.upper(),\n                            'condition': alert_condition.lower(),\n                            'price': alert_price,\n                            'created': datetime.now().isoformat()\n                        }\n                        settings['custom_alerts'].append(new_alert)\n                        st.success(\n                            f\"Alert added: {alert_symbol} {alert_condition.lower()} ‚Çπ{alert_price}\"\n                        )\n                        st.rerun()\n\n        # Display existing custom alerts\n        if settings['custom_alerts']:\n            st.write(\"**Active Custom Alerts:**\")\n\n            for i, alert in enumerate(settings['custom_alerts']):\n                col1, col2 = st.columns([4, 1])\n\n                with col1:\n                    st.write(\n                        f\"‚Ä¢ {alert['symbol']} {alert['condition']} ‚Çπ{alert['price']:.2f}\"\n                    )\n\n                with col2:\n                    if st.button(\"üóëÔ∏è\", key=f\"delete_alert_{i}\"):\n                        settings['custom_alerts'].pop(i)\n                        st.rerun()\n\n    with tab4:\n        st.header(\"üß™ Testing & Diagnostics\")\n\n        # Test notifications\n        st.subheader(\"üìß Test Notifications\")\n\n        col1, col2 = st.columns(2)\n\n        with col1:\n            if st.button(\"üìß Send Test Email\", use_container_width=True):\n                with st.spinner(\"Sending test email...\"):\n                    try:\n                        success = send_email_report(\n                            settings.get('recipient_email',\n                                         'user@example.com'),\n                            \"üß™ Test Email - AI Trading Agent\",\n                            \"<h2>Test Email</h2><p>Your email notifications are working correctly!</p><p>This is a test message from your AI Trading Agent.</p>\"\n                        )\n\n                        if success:\n                            st.success(\"‚úÖ Test email sent successfully!\")\n                        else:\n                            st.error(\"‚ùå Failed to send test email\")\n                    except Exception as e:\n                        st.error(f\"Error: {str(e)}\")\n\n        with col2:\n            if st.button(\"üí¨ Send Test WhatsApp\", use_container_width=True):\n                with st.spinner(\"Sending test WhatsApp...\"):\n                    try:\n                        success = send_whatsapp_message(\n                            settings.get('recipient_phone', '+919999999999'),\n                            \"üß™ Test message from AI Trading Agent! Your WhatsApp notifications are working perfectly. üöÄ\"\n                        )\n\n                        if success:\n                            st.success(\"‚úÖ Test WhatsApp sent successfully!\")\n                        else:\n                            st.error(\"‚ùå Failed to send test WhatsApp\")\n                    except Exception as e:\n                        st.error(f\"Error: {str(e)}\")\n\n        # System diagnostics\n        st.subheader(\"üîß System Diagnostics\")\n\n        if st.button(\"üîç Run System Check\", use_container_width=True):\n            with st.spinner(\"Running diagnostics...\"):\n                try:\n                    test_results = test_notification_setup()\n\n                    st.write(\"**üìä Diagnostic Results:**\")\n\n                    col1, col2 = st.columns(2)\n\n                    with col1:\n                        st.write(\"**Email Configuration:**\")\n                        if test_results.get('email_config'):\n                            st.success(\"‚úÖ Email settings configured\")\n                        else:\n                            st.error(\"‚ùå Email settings missing\")\n\n                        if test_results.get('smtp_connection'):\n                            st.success(\"‚úÖ SMTP connection successful\")\n                        else:\n                            st.error(\"‚ùå SMTP connection failed\")\n\n                    with col2:\n                        st.write(\"**WhatsApp Configuration:**\")\n                        if test_results.get('twilio_config'):\n                            st.success(\"‚úÖ Twilio settings configured\")\n                        else:\n                            st.error(\"‚ùå Twilio settings missing\")\n\n                        if test_results.get('twilio_connection'):\n                            st.success(\"‚úÖ Twilio connection successful\")\n                        else:\n                            st.error(\"‚ùå Twilio connection failed\")\n\n                except Exception as e:\n                    st.error(f\"Diagnostic error: {str(e)}\")\n\n        # Scheduler status\n        st.subheader(\"‚è∞ Scheduler Status\")\n\n        try:\n            scheduler = get_scheduler_instance()\n\n            if scheduler.running:\n                st.success(\"‚úÖ Automated scheduler is running\")\n            else:\n                st.warning(\"‚ö†Ô∏è Automated scheduler is stopped\")\n\n            # Display scheduled jobs\n            jobs = scheduler.get_scheduled_jobs()\n\n            if jobs:\n                st.write(\"**Scheduled Jobs:**\")\n                job_df = pd.DataFrame(jobs)\n                st.dataframe(job_df, use_container_width=True, hide_index=True)\n\n            # Scheduler controls\n            col1, col2 = st.columns(2)\n\n            with col1:\n                if st.button(\"‚ñ∂Ô∏è Start Scheduler\"):\n                    scheduler.start_scheduler()\n                    st.success(\"Scheduler started!\")\n                    st.rerun()\n\n            with col2:\n                if st.button(\"‚è∏Ô∏è Stop Scheduler\"):\n                    scheduler.stop_scheduler()\n                    st.warning(\"Scheduler stopped!\")\n                    st.rerun()\n\n        except Exception as e:\n            st.error(f\"Scheduler error: {str(e)}\")\n\n        # Generate sample report\n        st.subheader(\"üìÑ Sample Report Preview\")\n\n        if st.button(\"üìñ Generate Sample Report\"):\n            with st.spinner(\"Generating sample daily report...\"):\n                try:\n                    # Generate sample market summary\n                    market_summary = generate_daily_market_summary()\n\n                    if market_summary:\n                        st.write(\"**Sample Daily Report Content:**\")\n                        st.markdown(market_summary)\n                    else:\n                        st.info(\n                            \"Sample report generation temporarily unavailable\")\n\n                except Exception as e:\n                    st.error(f\"Error generating sample report: {str(e)}\")\n\n    # Save settings button\n    st.markdown(\"---\")\n\n    col1, col2, col3 = st.columns([1, 2, 1])\n\n    with col2:\n        if st.button(\"üíæ Save All Settings\", use_container_width=True):\n            # Update session state\n            st.session_state.app_settings = settings\n\n            # Save to file\n            if save_settings(settings):\n                st.success(\"‚úÖ Settings saved successfully!\")\n\n                # Restart scheduler with new settings if needed\n                try:\n                    scheduler = get_scheduler_instance()\n                    if scheduler.running:\n                        st.info(\"üîÑ Restarting scheduler with new settings...\")\n                        scheduler.stop_scheduler()\n                        scheduler.start_scheduler()\n                except:\n                    pass\n            else:\n                st.error(\"‚ùå Failed to save settings\")\n\n    # Environment variables info\n    st.sidebar.header(\"üîß Environment Setup\")\n\n    st.sidebar.info(\"\"\"\n    **Required Environment Variables:**\n    - `OPENAI_API_KEY`: OpenAI API key\n    - `EMAIL_ADDRESS`: SMTP email\n    - `EMAIL_PASSWORD`: SMTP password  \n    - `TWILIO_ACCOUNT_SID`: Twilio SID\n    - `TWILIO_AUTH_TOKEN`: Twilio token\n    - `TWILIO_PHONE_NUMBER`: Twilio phone\n    \"\"\")\n\n    # Current environment status\n    env_vars = [\n        'OPENAI_API_KEY', 'EMAIL_ADDRESS', 'EMAIL_PASSWORD',\n        'TWILIO_ACCOUNT_SID', 'TWILIO_AUTH_TOKEN', 'TWILIO_PHONE_NUMBER'\n    ]\n\n    st.sidebar.write(\"**Environment Status:**\")\n    for var in env_vars:\n        if os.environ.get(var):\n            st.sidebar.success(f\"‚úÖ {var}\")\n        else:\n            st.sidebar.error(f\"‚ùå {var}\")\n\n    st.sidebar.markdown(\n        f\"**Last updated:** {datetime.now().strftime('%H:%M:%S')}\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":24512},"pages/login.py":{"content":"from utils import load_css\nload_css(\"style/style.css\")\n\nimport streamlit as st\n\nst.title(\"Login to Dravyum\")\n\nusername = st.text_input(\"Email\")\npassword = st.text_input(\"Password\", type=\"password\")\n\nif st.button(\"Login\"):\n    if username == \"admin\" and password == \"1234\":\n        st.success(\"Login successful!\")\n        st.session_state['logged_in'] = True\n    else:\n        st.error(\"Invalid¬†credentials\")\n","size_bytes":409},"style/style.css":{"content":"/* Body & Base */\nbody {\n    background-color: #f5f7fa;\n    color: #1a1a1a;\n    font-family: 'Helvetica Neue', Arial, sans-serif;\n    margin: 0;\n}\n\n/* Header */\n.header {\n    background-color: #1f202e;\n    color: white;\n    padding: 15px 30px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n.header nav a {\n    color: white;\n    margin-left: 20px;\n    text-decoration: none;\n    font-weight: 500;\n}\n.header nav a:hover {\n    text-decoration: underline;\n}\n\n/* Layout */\n.container {\n    display: flex;\n    padding: 20px;\n}\n\n/* Main Content */\nmain {\n    flex: 3;\n    margin-right: 20px;\n}\n.card {\n    background-color: #ffffff;\n    border-radius: 8px;\n    padding: 15px;\n    margin-bottom: 15px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.05);\n}\n\n/* Sidebar */\n.sidebar {\n    flex: 1;\n    background-color: #ffffff;\n    border-radius: 8px;\n    padding: 15px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.05);\n}\n\n/* Buttons */\n.button {\n    background-color: #F5A623;\n    color: white;\n    padding: 10px 16px;\n    border: none;\n    border-radius: 5px;\n    font-weight: bold;\n    cursor: pointer;\n}\n.button:hover {\n    background-color: #d68f1a;\n}\n\n/* Positive/Negative */\n.positive {\n    color: #21ba45;\n}\n.negative {\n    color: #db2828;\n}\n\n/* Footer */\n.footer {\n    background-color: #0047AB;\n    color: white;\n    text-align: center;\n    padding: 10px 0;\n    margin-top: 20px;\n}","size_bytes":1406},"utils/ai_analysis.py":{"content":"import json\nimport os\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, Optional, List\nfrom datetime import datetime, timedelta\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\nimport requests\nfrom .market_data import get_nifty_data, get_stock_data, get_top_gainers_losers\n\ndef get_market_sentiment_analysis() -> Optional[Dict]:\n    \"\"\"\n    Generate statistical market sentiment analysis using current market data\n    Free and open-source alternative to paid AI APIs\n    \"\"\"\n    try:\n        # Fetch current market data\n        nifty_data = get_nifty_data(period=\"1mo\")\n        gainers, losers = get_top_gainers_losers()\n        \n        if nifty_data.empty:\n            return None\n        \n        # Prepare market context\n        current_price = nifty_data['Close'].iloc[-1]\n        prev_price = nifty_data['Close'].iloc[-2] if len(nifty_data) > 1 else current_price\n        change_pct = ((current_price - prev_price) / prev_price) * 100 if prev_price != 0 else 0\n        \n        # Calculate technical indicators\n        returns = nifty_data['Close'].pct_change().dropna()\n        volatility = returns.std() * np.sqrt(252) * 100 if len(returns) > 0 else 0\n        \n        # Volume analysis\n        if 'Volume' in nifty_data.columns and len(nifty_data) >= 20:\n            avg_volume = nifty_data['Volume'].rolling(20).mean().iloc[-1]\n            current_volume = nifty_data['Volume'].iloc[-1]\n            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1\n        else:\n            volume_ratio = 1\n        \n        # Moving averages for trend analysis\n        if len(nifty_data) >= 20:\n            ma_20 = nifty_data['Close'].rolling(20).mean().iloc[-1]\n            trend_strength = (current_price - ma_20) / ma_20 * 100\n        else:\n            trend_strength = change_pct\n            \n        # Sentiment scoring algorithm (rule-based)\n        sentiment_score = 0\n        sentiment_score += min(max(change_pct / 2, -1), 1)  # Price change component\n        sentiment_score += min(max((len(gainers) - len(losers)) / 100, -0.5), 0.5)  # Breadth component\n        sentiment_score += min(max((volume_ratio - 1) * 0.3, -0.3), 0.3)  # Volume component\n        sentiment_score += min(max(trend_strength / 5, -0.4), 0.4)  # Trend component\n        \n        # Determine sentiment\n        if sentiment_score > 0.3:\n            sentiment = \"bullish\"\n            direction = \"upward\"\n        elif sentiment_score < -0.3:\n            sentiment = \"bearish\"\n            direction = \"downward\"\n        else:\n            sentiment = \"neutral\"\n            direction = \"sideways\"\n            \n        # Calculate probability based on trend strength and volatility\n        probability = min(0.9, max(0.1, 0.5 + abs(sentiment_score) * 0.8))\n        \n        # Duration based on volatility and momentum\n        if volatility > 25:\n            duration = \"1-3 days\"\n        elif volatility > 15:\n            duration = \"1-2 weeks\"\n        else:\n            duration = \"1 month\"\n            \n        # Risk level assessment\n        if volatility > 30:\n            risk_level = \"high\"\n        elif volatility > 20:\n            risk_level = \"medium\"\n        else:\n            risk_level = \"low\"\n            \n        # Key factors identification\n        key_factors = []\n        if abs(change_pct) > 1:\n            key_factors.append(f\"Strong price movement ({change_pct:+.1f}%)\")\n        if volume_ratio > 1.5:\n            key_factors.append(\"High trading volume\")\n        elif volume_ratio < 0.7:\n            key_factors.append(\"Low trading volume\")\n        if volatility > 25:\n            key_factors.append(\"High market volatility\")\n        if len(gainers) > len(losers) * 2:\n            key_factors.append(\"Broad market strength\")\n        elif len(losers) > len(gainers) * 2:\n            key_factors.append(\"Broad market weakness\")\n            \n        analysis_text = f\"Market shows {sentiment} sentiment with {probability:.1%} confidence. \" \\\n                       f\"Current NIFTY at {current_price:.2f} ({change_pct:+.2f}%). \" \\\n                       f\"Volatility at {volatility:.1f}% indicates {risk_level} risk environment.\"\n        \n        # Return statistical analysis result (free alternative to OpenAI)\n        result = {\n            \"analysis\": analysis_text,\n            \"sentiment\": sentiment,\n            \"probability\": round(probability, 2),\n            \"direction\": direction,\n            \"duration\": duration,\n            \"risk_level\": risk_level,\n            \"key_factors\": key_factors if key_factors else [\"Standard market conditions\"]\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"Error in AI market sentiment analysis: {e}\")\n        return None\n\ndef analyze_stock_probability(symbol: str, timeframe: str = \"1 week\") -> Optional[Dict]:\n    \"\"\"\n    Analyze probability of stock price movement using statistical methods\n    Free and open-source alternative to paid AI APIs\n    \"\"\"\n    try:\n        # Fetch stock data\n        stock_data = get_stock_data(symbol, period=\"3mo\")\n        if stock_data.empty:\n            return None\n        \n        # Calculate technical indicators\n        current_price = stock_data['Close'].iloc[-1]\n        \n        # Ensure we have enough data\n        if len(stock_data) < 50:\n            return None\n            \n        sma_20 = stock_data['Close'].rolling(20).mean().iloc[-1]\n        sma_50 = stock_data['Close'].rolling(50).mean().iloc[-1]\n        \n        # Calculate RSI\n        delta = stock_data['Close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n        rs = gain / loss\n        rsi = 100 - (100 / (1 + rs.iloc[-1])) if rs.iloc[-1] > 0 else 50\n        \n        # Volume analysis\n        if 'Volume' in stock_data.columns:\n            avg_volume = stock_data['Volume'].rolling(20).mean().iloc[-1]\n            current_volume = stock_data['Volume'].iloc[-1]\n            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1\n        else:\n            volume_ratio = 1\n        \n        # Statistical probability calculation\n        returns = stock_data['Close'].pct_change().dropna()\n        mean_return = returns.mean()\n        std_return = returns.std()\n        \n        # Price momentum indicators\n        price_momentum = (current_price - sma_20) / sma_20 * 100\n        trend_strength = (sma_20 - sma_50) / sma_50 * 100\n        \n        # Probability scoring system\n        upward_signals = 0\n        downward_signals = 0\n        \n        # RSI signals\n        if rsi < 30:\n            upward_signals += 2  # Oversold\n        elif rsi > 70:\n            downward_signals += 2  # Overbought\n        elif 45 <= rsi <= 55:\n            upward_signals += 1  # Neutral momentum\n            \n        # Moving average signals\n        if current_price > sma_20 > sma_50:\n            upward_signals += 2  # Strong uptrend\n        elif current_price < sma_20 < sma_50:\n            downward_signals += 2  # Strong downtrend\n        elif current_price > sma_20:\n            upward_signals += 1  # Price above short MA\n            \n        # Volume confirmation\n        if volume_ratio > 1.2:\n            if price_momentum > 0:\n                upward_signals += 1\n            else:\n                downward_signals += 1\n                \n        # Statistical momentum\n        if mean_return > 0:\n            upward_signals += 1\n        else:\n            downward_signals += 1\n            \n        # Calculate probabilities\n        total_signals = upward_signals + downward_signals\n        if total_signals > 0:\n            upward_prob = upward_signals / total_signals\n            downward_prob = downward_signals / total_signals\n        else:\n            upward_prob = downward_prob = 0.5\n            \n        # Adjust for volatility\n        volatility = std_return * np.sqrt(252) * 100\n        confidence = max(0.3, min(0.9, 1 - volatility / 50))\n        \n        # Price range estimation\n        volatility_factor = std_return * 1.96  # 95% confidence interval\n        if timeframe == \"1 week\":\n            time_factor = np.sqrt(5)  # 5 trading days\n        elif timeframe == \"1 month\":\n            time_factor = np.sqrt(20)  # 20 trading days\n        else:\n            time_factor = np.sqrt(5)\n            \n        price_range_factor = volatility_factor * time_factor\n        upper_range = current_price * (1 + price_range_factor)\n        lower_range = current_price * (1 - price_range_factor)\n        \n        # Technical signals summary\n        signals = []\n        if rsi < 30:\n            signals.append(\"Oversold RSI\")\n        elif rsi > 70:\n            signals.append(\"Overbought RSI\")\n        if current_price > sma_20:\n            signals.append(\"Above 20-day MA\")\n        if sma_20 > sma_50:\n            signals.append(\"Bullish MA crossover\")\n        if volume_ratio > 1.5:\n            signals.append(\"High volume\")\n        elif volume_ratio < 0.7:\n            signals.append(\"Low volume\")\n        \n        # Recommendation logic\n        if upward_prob > 0.6:\n            recommendation = \"buy\"\n        elif downward_prob > 0.6:\n            recommendation = \"sell\"\n        else:\n            recommendation = \"hold\"\n            \n        # Return statistical analysis result (free alternative to OpenAI)\n        result = {\n            \"symbol\": symbol,\n            \"timeframe\": timeframe,\n            \"upward_probability\": round(upward_prob, 2),\n            \"downward_probability\": round(downward_prob, 2),\n            \"expected_price_range\": {\n                \"low\": round(lower_range, 2),\n                \"high\": round(upper_range, 2)\n            },\n            \"confidence\": round(confidence, 2),\n            \"technical_signals\": signals if signals else [\"Standard technical setup\"],\n            \"recommendation\": recommendation\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"Error in stock probability analysis for {symbol}: {e}\")\n        return None\n\ndef generate_daily_market_summary() -> Optional[str]:\n    \"\"\"\n    Generate a comprehensive daily market summary using statistical analysis\n    Free and open-source alternative to paid AI APIs\n    \"\"\"\n    try:\n        # Gather market data\n        nifty_data = get_nifty_data(period=\"5d\")\n        gainers, losers = get_top_gainers_losers()\n        \n        if nifty_data.empty:\n            return None\n        \n        # Market metrics\n        current_price = nifty_data['Close'].iloc[-1]\n        prev_price = nifty_data['Close'].iloc[-2] if len(nifty_data) > 1 else current_price\n        daily_change = current_price - prev_price\n        daily_change_pct = (daily_change / prev_price) * 100 if prev_price != 0 else 0\n        \n        # Volume analysis\n        if 'Volume' in nifty_data.columns and len(nifty_data) >= 5:\n            current_volume = nifty_data['Volume'].iloc[-1]\n            avg_volume = nifty_data['Volume'].rolling(5).mean().iloc[-2]\n            volume_change = ((current_volume - avg_volume) / avg_volume) * 100 if avg_volume > 0 else 0\n        else:\n            volume_change = 0\n        \n        # Top performers\n        top_gainers = gainers.head(3)['Symbol'].tolist() if not gainers.empty else []\n        top_losers = losers.head(3)['Symbol'].tolist() if not losers.empty else []\n        \n        # Market analysis (rule-based)\n        market_direction = \"bullish\" if daily_change_pct > 1 else \"bearish\" if daily_change_pct < -1 else \"neutral\"\n        volume_assessment = \"high\" if volume_change > 20 else \"low\" if volume_change < -20 else \"average\"\n        breadth_ratio = len(gainers) / (len(gainers) + len(losers)) if (len(gainers) + len(losers)) > 0 else 0.5\n        market_breadth = \"positive\" if breadth_ratio > 0.6 else \"negative\" if breadth_ratio < 0.4 else \"mixed\"\n        \n        # Generate summary\n        summary = f\"\"\"Daily Market Summary for {datetime.now().strftime('%Y-%m-%d')}:\n\nMARKET OVERVIEW:\nThe NIFTY 50 closed at {current_price:.2f}, {daily_change:+.2f} points ({daily_change_pct:+.2f}%). \nMarket sentiment appears {market_direction} with {volume_assessment} trading volume ({volume_change:+.1f}% vs 5-day average).\n\nMARKET BREADTH:\nMarket breadth was {market_breadth} with {len(gainers)} advancing stocks and {len(losers)} declining stocks.\nThis indicates {'strong buying interest' if breadth_ratio > 0.6 else 'selling pressure' if breadth_ratio < 0.4 else 'mixed sentiment'} across the market.\n\nTOP PERFORMERS:\nLeading gainers: {', '.join(top_gainers) if top_gainers else 'No significant gainers'}\nMajor decliners: {', '.join(top_losers) if top_losers else 'No significant losers'}\n\nTECHNICAL OUTLOOK:\n{'Positive momentum suggests continued uptrend if sustained above current levels.' if daily_change_pct > 0 else 'Weakness observed, watch for support levels and potential reversal signals.' if daily_change_pct < -1 else 'Sideways movement indicates consolidation phase.'}\n\nTRADING RECOMMENDATIONS:\n{'Focus on momentum stocks with strong volume confirmation.' if market_direction == 'bullish' else 'Exercise caution, consider defensive positions and strict stop-losses.' if market_direction == 'bearish' else 'Range-bound trading approach recommended with defined entry/exit levels.'}\n\nKEY LEVELS TO WATCH:\nSupport: {current_price * 0.98:.2f} | Resistance: {current_price * 1.02:.2f}\n\n*This analysis is generated using statistical methods and market data. Please conduct your own research before making investment decisions.*\"\"\"\n        \n        return summary\n        \n    except Exception as e:\n        print(f\"Error generating daily market summary: {e}\")\n        return None\n\ndef analyze_portfolio_risk(portfolio: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Analyze portfolio risk using statistical methods\n    Free and open-source alternative to paid AI APIs\n    \"\"\"\n    try:\n        if not portfolio:\n            return None\n        \n        total_value = 0\n        sector_values = {}\n        stock_count = len(portfolio)\n        \n        # Calculate portfolio composition\n        for holding in portfolio:\n            symbol = holding.get('symbol', '')\n            quantity = holding.get('quantity', 0)\n            price = holding.get('current_price', 0)\n            value = quantity * price\n            total_value += value\n            \n            # Basic sector classification (simplified)\n            sector = \"other\"  # Default\n            if any(bank in symbol.upper() for bank in ['HDFC', 'ICICI', 'SBI', 'AXIS', 'KOTAK']):\n                sector = \"banking\"\n            elif any(tech in symbol.upper() for tech in ['TCS', 'INFY', 'WIPRO', 'HCLT', 'TECHM']):\n                sector = \"technology\"\n            elif any(pharma in symbol.upper() for pharma in ['DRREDDY', 'CIPLA', 'SUNPHARMA', 'BIOCON']):\n                sector = \"pharma\"\n            elif any(fmcg in symbol.upper() for fmcg in ['HINDUNILVR', 'ITC', 'NESTLIND', 'BRITANNIA']):\n                sector = \"fmcg\"\n            \n            sector_values[sector] = sector_values.get(sector, 0) + value\n        \n        # Calculate sector concentration percentages\n        sector_concentration = {}\n        for sector, value in sector_values.items():\n            sector_concentration[sector] = round((value / total_value) * 100, 1) if total_value > 0 else 0\n        \n        # Diversification score (higher is better)\n        # Based on number of stocks and sector distribution\n        diversification_score = min(10, (stock_count / 2) + (len(sector_values) / 2))\n        diversification_score = max(1, diversification_score)  # Minimum 1\n        \n        # Risk rating calculation\n        # Higher concentration = higher risk\n        max_sector_concentration = max(sector_concentration.values()) if sector_concentration else 100\n        concentration_risk = min(5, max_sector_concentration / 20)  # 0-5 scale\n        \n        # Portfolio size risk\n        size_risk = max(0, 3 - stock_count / 5)  # 0-3 scale, lower for larger portfolios\n        \n        risk_rating = min(10, max(1, int(concentration_risk + size_risk + 2)))  # 1-10 scale\n        \n        # Risk factors identification\n        risk_factors = []\n        if max_sector_concentration > 50:\n            risk_factors.append(f\"High sector concentration ({max_sector_concentration:.1f}% in single sector)\")\n        if stock_count < 5:\n            risk_factors.append(\"Low diversification (fewer than 5 stocks)\")\n        if stock_count < 3:\n            risk_factors.append(\"Very high concentration risk\")\n        if len(sector_values) < 3:\n            risk_factors.append(\"Limited sector diversification\")\n            \n        # Recommendations\n        recommendations = []\n        if max_sector_concentration > 40:\n            recommendations.append(\"Reduce sector concentration by diversifying across industries\")\n        if stock_count < 10:\n            recommendations.append(\"Consider adding more stocks to improve diversification\")\n        if \"banking\" in sector_concentration and sector_concentration[\"banking\"] > 30:\n            recommendations.append(\"Consider reducing banking sector exposure\")\n        if len(sector_values) < 4:\n            recommendations.append(\"Add stocks from different sectors (pharma, FMCG, auto, etc.)\")\n        if not recommendations:\n            recommendations.append(\"Portfolio shows reasonable diversification\")\n            \n        result = {\n            \"diversification_score\": round(diversification_score, 1),\n            \"sector_concentration\": sector_concentration,\n            \"risk_rating\": risk_rating,\n            \"risk_factors\": risk_factors if risk_factors else [\"Standard portfolio risk\"],\n            \"recommendations\": recommendations,\n            \"total_stocks\": stock_count,\n            \"total_value\": total_value\n        }\n        \n        return result\n        \n    except Exception as e:\n        print(f\"Error in portfolio risk analysis: {e}\")\n        return None\n\ndef get_ai_stock_recommendations(criteria: Dict) -> Optional[List[Dict]]:\n    \"\"\"\n    Get stock recommendations based on criteria using rule-based system\n    Free and open-source alternative to paid AI APIs\n    \"\"\"\n    try:\n        market_cap = criteria.get('market_cap', 'large')\n        sector = criteria.get('sector', 'any')\n        risk_level = criteria.get('risk_level', 'medium')\n        time_horizon = criteria.get('time_horizon', 'medium-term')\n        \n        # Predefined stock recommendations based on criteria\n        stock_universe = {\n            'large_cap_banking': [\n                {'symbol': 'HDFCBANK', 'company_name': 'HDFC Bank', 'sector': 'banking'},\n                {'symbol': 'ICICIBANK', 'company_name': 'ICICI Bank', 'sector': 'banking'},\n                {'symbol': 'SBIN', 'company_name': 'State Bank of India', 'sector': 'banking'},\n                {'symbol': 'AXISBANK', 'company_name': 'Axis Bank', 'sector': 'banking'}\n            ],\n            'large_cap_technology': [\n                {'symbol': 'TCS', 'company_name': 'Tata Consultancy Services', 'sector': 'technology'},\n                {'symbol': 'INFY', 'company_name': 'Infosys', 'sector': 'technology'},\n                {'symbol': 'WIPRO', 'company_name': 'Wipro', 'sector': 'technology'},\n                {'symbol': 'HCLTECH', 'company_name': 'HCL Technologies', 'sector': 'technology'}\n            ],\n            'large_cap_pharma': [\n                {'symbol': 'SUNPHARMA', 'company_name': 'Sun Pharmaceutical', 'sector': 'pharma'},\n                {'symbol': 'DRREDDY', 'company_name': 'Dr Reddys Labs', 'sector': 'pharma'},\n                {'symbol': 'CIPLA', 'company_name': 'Cipla', 'sector': 'pharma'},\n                {'symbol': 'DIVISLAB', 'company_name': 'Divis Laboratories', 'sector': 'pharma'}\n            ],\n            'large_cap_fmcg': [\n                {'symbol': 'HINDUNILVR', 'company_name': 'Hindustan Unilever', 'sector': 'fmcg'},\n                {'symbol': 'ITC', 'company_name': 'ITC Limited', 'sector': 'fmcg'},\n                {'symbol': 'NESTLEIND', 'company_name': 'Nestle India', 'sector': 'fmcg'},\n                {'symbol': 'BRITANNIA', 'company_name': 'Britannia Industries', 'sector': 'fmcg'}\n            ],\n            'large_cap_diversified': [\n                {'symbol': 'RELIANCE', 'company_name': 'Reliance Industries', 'sector': 'energy'},\n                {'symbol': 'ADANIPORTS', 'company_name': 'Adani Ports', 'sector': 'infrastructure'},\n                {'symbol': 'TATASTEEL', 'company_name': 'Tata Steel', 'sector': 'metals'},\n                {'symbol': 'LT', 'company_name': 'Larsen & Toubro', 'sector': 'engineering'}\n            ]\n        }\n        \n        # Select stocks based on criteria\n        recommendations = []\n        \n        # Choose stock pool based on sector preference\n        if sector == 'banking':\n            stock_pool = stock_universe['large_cap_banking']\n        elif sector == 'technology':\n            stock_pool = stock_universe['large_cap_technology']\n        elif sector == 'pharma':\n            stock_pool = stock_universe['large_cap_pharma']\n        elif sector == 'fmcg':\n            stock_pool = stock_universe['large_cap_fmcg']\n        else:  # 'any' or other\n            # Mix from different sectors\n            stock_pool = (stock_universe['large_cap_banking'][:2] + \n                         stock_universe['large_cap_technology'][:2] + \n                         stock_universe['large_cap_diversified'][:2])\n        \n        # Generate recommendations with scoring logic\n        for stock in stock_pool[:6]:  # Limit to 6 recommendations\n            # Simple scoring based on criteria\n            base_score = 7.0  # Base score out of 10\n            \n            # Adjust based on risk level\n            if risk_level == 'low':\n                risk_adjustment = 0.5 if stock['sector'] in ['banking', 'fmcg'] else -0.5\n            elif risk_level == 'high':\n                risk_adjustment = 0.5 if stock['sector'] in ['technology'] else 0\n            else:  # medium\n                risk_adjustment = 0\n            \n            final_score = min(10, max(5, base_score + risk_adjustment))\n            \n            # Generate target price (simplified estimation)\n            current_price = 1000  # Placeholder - would be fetched from market data in real implementation\n            upside = final_score * 2  # Simple correlation\n            target_price = current_price * (1 + upside / 100)\n            \n            # Generate rationale based on sector and criteria\n            rationales = {\n                'banking': 'Strong fundamentals, stable dividend yield, and regulatory compliance',\n                'technology': 'Digital transformation trends, export revenue, and margin expansion',\n                'pharma': 'Defensive sector, global market presence, and R&D pipeline',\n                'fmcg': 'Consistent demand, brand strength, and rural market penetration',\n                'energy': 'Integrated business model and renewable energy investments',\n                'infrastructure': 'Government infrastructure spending and economic growth',\n                'metals': 'Infrastructure demand and commodity price recovery',\n                'engineering': 'Order book visibility and execution capabilities'\n            }\n            \n            recommendation = {\n                'symbol': stock['symbol'],\n                'company_name': stock['company_name'],\n                'target_price': round(target_price, 2),\n                'upside_potential': round(upside, 1),\n                'rationale': rationales.get(stock['sector'], 'Solid business fundamentals and growth potential'),\n                'risk_rating': risk_level,\n                'sector': stock['sector'],\n                'score': round(final_score, 1),\n                'time_horizon': time_horizon\n            }\n            \n            recommendations.append(recommendation)\n        \n        return recommendations[:5]  # Return top 5 recommendations\n        \n    except Exception as e:\n        print(f\"Error getting stock recommendations: {e}\")\n        return None\n","size_bytes":24110},"utils/fundamentals.py":{"content":"import yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, Optional, List\nimport requests\nimport json\nfrom datetime import datetime, timedelta\n\ndef get_fundamental_data(symbol: str) -> Dict:\n    \"\"\"\n    Get comprehensive fundamental data for a stock\n    \"\"\"\n    try:\n        # Add .NS suffix for NSE stocks if not present\n        if not symbol.endswith('.NS') and not symbol.startswith('^'):\n            symbol = f\"{symbol}.NS\"\n        \n        ticker = yf.Ticker(symbol)\n        info = ticker.info\n        \n        # Get financial statements\n        financials = ticker.financials\n        balance_sheet = ticker.balance_sheet\n        cash_flow = ticker.cashflow\n        \n        fundamental_data = {\n            'basic_info': {\n                'symbol': symbol.replace('.NS', ''),\n                'company_name': info.get('longName', 'N/A'),\n                'sector': info.get('sector', 'N/A'),\n                'industry': info.get('industry', 'N/A'),\n                'market_cap': info.get('marketCap', 0),\n                'current_price': info.get('currentPrice', 0),\n                'currency': info.get('currency', 'INR')\n            },\n            'valuation_ratios': {\n                'pe_ratio': info.get('trailingPE', None),\n                'forward_pe': info.get('forwardPE', None),\n                'peg_ratio': info.get('pegRatio', None),\n                'price_to_book': info.get('priceToBook', None),\n                'price_to_sales': info.get('priceToSalesTrailing12Months', None),\n                'ev_to_revenue': info.get('enterpriseToRevenue', None),\n                'ev_to_ebitda': info.get('enterpriseToEbitda', None)\n            },\n            'profitability_ratios': {\n                'roe': info.get('returnOnEquity', None),\n                'roa': info.get('returnOnAssets', None),\n                'profit_margin': info.get('profitMargins', None),\n                'operating_margin': info.get('operatingMargins', None),\n                'gross_margin': info.get('grossMargins', None)\n            },\n            'financial_health': {\n                'debt_to_equity': info.get('debtToEquity', None),\n                'current_ratio': info.get('currentRatio', None),\n                'quick_ratio': info.get('quickRatio', None),\n                'total_cash': info.get('totalCash', None),\n                'total_debt': info.get('totalDebt', None),\n                'free_cash_flow': info.get('freeCashflow', None)\n            },\n            'growth_metrics': {\n                'revenue_growth': info.get('revenueGrowth', None),\n                'earnings_growth': info.get('earningsGrowth', None),\n                'revenue_quarterly_growth': info.get('revenueQuarterlyGrowth', None),\n                'earnings_quarterly_growth': info.get('earningsQuarterlyGrowth', None)\n            },\n            'dividend_info': {\n                'dividend_yield': info.get('dividendYield', None),\n                'dividend_rate': info.get('dividendRate', None),\n                'payout_ratio': info.get('payoutRatio', None),\n                'ex_dividend_date': info.get('exDividendDate', None)\n            },\n            'analyst_info': {\n                'recommendation': info.get('recommendationKey', 'N/A'),\n                'target_price': info.get('targetMeanPrice', None),\n                'analyst_count': info.get('numberOfAnalystOpinions', 0)\n            }\n        }\n        \n        # Calculate additional ratios if financial data is available\n        if not financials.empty and not balance_sheet.empty:\n            try:\n                # Get latest year data\n                latest_financials = financials.iloc[:, 0]\n                latest_balance = balance_sheet.iloc[:, 0]\n                \n                # Calculate custom ratios\n                total_revenue = latest_financials.get('Total Revenue', 0)\n                net_income = latest_financials.get('Net Income', 0)\n                total_assets = latest_balance.get('Total Assets', 0)\n                total_equity = latest_balance.get('Stockholders Equity', 0)\n                \n                if total_assets > 0:\n                    fundamental_data['custom_ratios'] = {\n                        'asset_turnover': total_revenue / total_assets if total_assets > 0 else None,\n                        'equity_multiplier': total_assets / total_equity if total_equity > 0 else None,\n                        'net_profit_margin': net_income / total_revenue if total_revenue > 0 else None\n                    }\n            except Exception as e:\n                print(f\"Error calculating custom ratios: {e}\")\n        \n        return fundamental_data\n        \n    except Exception as e:\n        print(f\"Error fetching fundamental data for {symbol}: {e}\")\n        return {}\n\ndef calculate_financial_score(fundamental_data: Dict) -> Dict:\n    \"\"\"\n    Calculate a comprehensive financial health score\n    \"\"\"\n    try:\n        score_components = {\n            'valuation': 0,\n            'profitability': 0,\n            'financial_health': 0,\n            'growth': 0,\n            'dividend': 0\n        }\n        \n        max_scores = {\n            'valuation': 25,\n            'profitability': 25,\n            'financial_health': 25,\n            'growth': 20,\n            'dividend': 5\n        }\n        \n        # Valuation scoring\n        valuation = fundamental_data.get('valuation_ratios', {})\n        pe_ratio = valuation.get('pe_ratio')\n        pb_ratio = valuation.get('price_to_book')\n        \n        if pe_ratio:\n            if 10 <= pe_ratio <= 25:\n                score_components['valuation'] += 15\n            elif 5 <= pe_ratio < 10 or 25 < pe_ratio <= 35:\n                score_components['valuation'] += 10\n            elif pe_ratio < 5 or pe_ratio > 35:\n                score_components['valuation'] += 5\n        \n        if pb_ratio:\n            if 1 <= pb_ratio <= 3:\n                score_components['valuation'] += 10\n            elif 0.5 <= pb_ratio < 1 or 3 < pb_ratio <= 5:\n                score_components['valuation'] += 5\n        \n        # Profitability scoring\n        profitability = fundamental_data.get('profitability_ratios', {})\n        roe = profitability.get('roe')\n        profit_margin = profitability.get('profit_margin')\n        \n        if roe:\n            if roe >= 0.15:\n                score_components['profitability'] += 15\n            elif roe >= 0.10:\n                score_components['profitability'] += 10\n            elif roe >= 0.05:\n                score_components['profitability'] += 5\n        \n        if profit_margin:\n            if profit_margin >= 0.15:\n                score_components['profitability'] += 10\n            elif profit_margin >= 0.10:\n                score_components['profitability'] += 7\n            elif profit_margin >= 0.05:\n                score_components['profitability'] += 5\n        \n        # Financial health scoring\n        financial_health = fundamental_data.get('financial_health', {})\n        debt_to_equity = financial_health.get('debt_to_equity')\n        current_ratio = financial_health.get('current_ratio')\n        \n        if debt_to_equity is not None:\n            if debt_to_equity <= 0.5:\n                score_components['financial_health'] += 15\n            elif debt_to_equity <= 1.0:\n                score_components['financial_health'] += 10\n            elif debt_to_equity <= 2.0:\n                score_components['financial_health'] += 5\n        \n        if current_ratio:\n            if current_ratio >= 1.5:\n                score_components['financial_health'] += 10\n            elif current_ratio >= 1.0:\n                score_components['financial_health'] += 7\n        \n        # Growth scoring\n        growth = fundamental_data.get('growth_metrics', {})\n        revenue_growth = growth.get('revenue_growth')\n        earnings_growth = growth.get('earnings_growth')\n        \n        if revenue_growth:\n            if revenue_growth >= 0.20:\n                score_components['growth'] += 10\n            elif revenue_growth >= 0.10:\n                score_components['growth'] += 7\n            elif revenue_growth >= 0.05:\n                score_components['growth'] += 5\n        \n        if earnings_growth:\n            if earnings_growth >= 0.20:\n                score_components['growth'] += 10\n            elif earnings_growth >= 0.10:\n                score_components['growth'] += 7\n            elif earnings_growth >= 0.05:\n                score_components['growth'] += 5\n        \n        # Dividend scoring\n        dividend = fundamental_data.get('dividend_info', {})\n        dividend_yield = dividend.get('dividend_yield')\n        \n        if dividend_yield and dividend_yield > 0:\n            if 0.02 <= dividend_yield <= 0.06:\n                score_components['dividend'] += 5\n            elif dividend_yield > 0:\n                score_components['dividend'] += 3\n        \n        # Calculate total score and rating\n        total_score = sum(score_components.values())\n        max_total = sum(max_scores.values())\n        percentage_score = (total_score / max_total) * 100\n        \n        # Determine rating\n        if percentage_score >= 80:\n            rating = 'Excellent'\n        elif percentage_score >= 70:\n            rating = 'Good'\n        elif percentage_score >= 60:\n            rating = 'Average'\n        elif percentage_score >= 50:\n            rating = 'Below Average'\n        else:\n            rating = 'Poor'\n        \n        return {\n            'total_score': total_score,\n            'max_score': max_total,\n            'percentage': percentage_score,\n            'rating': rating,\n            'component_scores': score_components,\n            'max_component_scores': max_scores\n        }\n        \n    except Exception as e:\n        print(f\"Error calculating financial score: {e}\")\n        return {}\n\ndef get_peer_comparison(symbol: str, sector: str = None) -> Dict:\n    \"\"\"\n    Compare stock with sector peers\n    \"\"\"\n    try:\n        # Get fundamental data for the stock\n        stock_data = get_fundamental_data(symbol)\n        \n        if not stock_data:\n            return {}\n        \n        # Common Indian stocks by sector for comparison\n        sector_stocks = {\n            'Technology': ['TCS.NS', 'INFY.NS', 'WIPRO.NS', 'TECHM.NS', 'HCLTECH.NS'],\n            'Banking': ['HDFCBANK.NS', 'ICICIBANK.NS', 'SBIN.NS', 'KOTAKBANK.NS', 'AXISBANK.NS'],\n            'Oil & Gas': ['RELIANCE.NS', 'ONGC.NS', 'IOC.NS', 'BPCL.NS', 'HINDPETRO.NS'],\n            'Pharmaceuticals': ['SUNPHARMA.NS', 'DRREDDY.NS', 'CIPLA.NS', 'DIVISLAB.NS', 'BIOCON.NS'],\n            'Automobiles': ['MARUTI.NS', 'TATAMOTORS.NS', 'M&M.NS', 'BAJAJ-AUTO.NS', 'EICHERMOT.NS']\n        }\n        \n        # Determine sector\n        stock_sector = sector or stock_data.get('basic_info', {}).get('sector', '')\n        peer_symbols = []\n        \n        # Find appropriate peer group\n        for sect, stocks in sector_stocks.items():\n            if sect.lower() in stock_sector.lower():\n                peer_symbols = [s for s in stocks if s != f\"{symbol}.NS\"]\n                break\n        \n        if not peer_symbols:\n            # Use random selection from all stocks if sector not found\n            all_stocks = [stock for stocks in sector_stocks.values() for stock in stocks]\n            peer_symbols = all_stocks[:5]\n        \n        # Get peer data\n        peer_data = []\n        for peer_symbol in peer_symbols[:5]:  # Limit to 5 peers\n            peer_fundamentals = get_fundamental_data(peer_symbol.replace('.NS', ''))\n            if peer_fundamentals:\n                peer_data.append(peer_fundamentals)\n        \n        # Calculate sector averages\n        sector_averages = {}\n        if peer_data:\n            metrics_to_average = [\n                ('valuation_ratios', 'pe_ratio'),\n                ('valuation_ratios', 'price_to_book'),\n                ('profitability_ratios', 'roe'),\n                ('profitability_ratios', 'profit_margin'),\n                ('financial_health', 'debt_to_equity'),\n                ('growth_metrics', 'revenue_growth')\n            ]\n            \n            for category, metric in metrics_to_average:\n                values = []\n                for peer in peer_data:\n                    value = peer.get(category, {}).get(metric)\n                    if value is not None:\n                        values.append(value)\n                \n                if values:\n                    sector_averages[f\"{category}_{metric}\"] = {\n                        'average': np.mean(values),\n                        'median': np.median(values),\n                        'min': np.min(values),\n                        'max': np.max(values)\n                    }\n        \n        # Compare stock with sector\n        stock_metrics = {}\n        for category, metric in [\n            ('valuation_ratios', 'pe_ratio'),\n            ('valuation_ratios', 'price_to_book'),\n            ('profitability_ratios', 'roe'),\n            ('profitability_ratios', 'profit_margin'),\n            ('financial_health', 'debt_to_equity'),\n            ('growth_metrics', 'revenue_growth')\n        ]:\n            stock_value = stock_data.get(category, {}).get(metric)\n            sector_avg = sector_averages.get(f\"{category}_{metric}\", {}).get('average')\n            \n            if stock_value is not None and sector_avg is not None:\n                stock_metrics[f\"{category}_{metric}\"] = {\n                    'stock_value': stock_value,\n                    'sector_average': sector_avg,\n                    'vs_sector': ((stock_value - sector_avg) / sector_avg) * 100 if sector_avg != 0 else 0\n                }\n        \n        return {\n            'stock_symbol': symbol,\n            'sector': stock_sector,\n            'peer_symbols': [p.replace('.NS', '') for p in peer_symbols],\n            'sector_averages': sector_averages,\n            'comparison': stock_metrics,\n            'peer_count': len(peer_data)\n        }\n        \n    except Exception as e:\n        print(f\"Error in peer comparison for {symbol}: {e}\")\n        return {}\n\ndef get_dividend_analysis(symbol: str) -> Dict:\n    \"\"\"\n    Detailed dividend analysis\n    \"\"\"\n    try:\n        if not symbol.endswith('.NS') and not symbol.startswith('^'):\n            symbol = f\"{symbol}.NS\"\n        \n        ticker = yf.Ticker(symbol)\n        \n        # Get dividend history\n        dividends = ticker.dividends\n        \n        if dividends.empty:\n            return {'has_dividends': False, 'message': 'No dividend history found'}\n        \n        # Calculate dividend metrics\n        recent_dividends = dividends.tail(4)  # Last 4 dividends\n        annual_dividend = recent_dividends.sum()\n        \n        # Get current price\n        current_price = ticker.info.get('currentPrice', 0)\n        dividend_yield = (annual_dividend / current_price) * 100 if current_price > 0 else 0\n        \n        # Dividend growth analysis\n        yearly_dividends = dividends.resample('Y').sum()\n        if len(yearly_dividends) >= 2:\n            dividend_growth_rates = yearly_dividends.pct_change().dropna()\n            avg_growth_rate = dividend_growth_rates.mean() * 100\n            consistent_growth = (dividend_growth_rates > 0).sum() / len(dividend_growth_rates) * 100\n        else:\n            avg_growth_rate = 0\n            consistent_growth = 0\n        \n        # Payout ratio\n        earnings_per_share = ticker.info.get('trailingEps', 0)\n        payout_ratio = (annual_dividend / earnings_per_share) * 100 if earnings_per_share > 0 else 0\n        \n        return {\n            'has_dividends': True,\n            'annual_dividend': annual_dividend,\n            'dividend_yield': dividend_yield,\n            'avg_growth_rate': avg_growth_rate,\n            'payout_ratio': payout_ratio,\n            'consistent_growth_percentage': consistent_growth,\n            'total_payments': len(dividends),\n            'last_payment_date': dividends.index[-1] if not dividends.empty else None,\n            'last_payment_amount': dividends.iloc[-1] if not dividends.empty else 0,\n            'dividend_frequency': 'Quarterly' if len(recent_dividends) >= 4 else 'Annual'\n        }\n        \n    except Exception as e:\n        print(f\"Error in dividend analysis for {symbol}: {e}\")\n        return {'has_dividends': False, 'error': str(e)}\n\ndef get_financial_statements_summary(symbol: str) -> Dict:\n    \"\"\"\n    Get summarized financial statements\n    \"\"\"\n    try:\n        if not symbol.endswith('.NS') and not symbol.startswith('^'):\n            symbol = f\"{symbol}.NS\"\n        \n        ticker = yf.Ticker(symbol)\n        \n        # Get financial statements\n        financials = ticker.financials\n        balance_sheet = ticker.balance_sheet\n        cash_flow = ticker.cashflow\n        \n        summary = {}\n        \n        # Income Statement Summary (latest year)\n        if not financials.empty:\n            latest_financials = financials.iloc[:, 0]\n            summary['income_statement'] = {\n                'total_revenue': latest_financials.get('Total Revenue', 0),\n                'gross_profit': latest_financials.get('Gross Profit', 0),\n                'operating_income': latest_financials.get('Operating Income', 0),\n                'net_income': latest_financials.get('Net Income', 0),\n                'ebitda': latest_financials.get('EBITDA', 0),\n                'year': financials.columns[0].year if len(financials.columns) > 0 else None\n            }\n        \n        # Balance Sheet Summary (latest year)\n        if not balance_sheet.empty:\n            latest_balance = balance_sheet.iloc[:, 0]\n            summary['balance_sheet'] = {\n                'total_assets': latest_balance.get('Total Assets', 0),\n                'total_liabilities': latest_balance.get('Total Liabilities Net Minority Interest', 0),\n                'stockholders_equity': latest_balance.get('Stockholders Equity', 0),\n                'cash_and_equivalents': latest_balance.get('Cash And Cash Equivalents', 0),\n                'total_debt': latest_balance.get('Total Debt', 0),\n                'year': balance_sheet.columns[0].year if len(balance_sheet.columns) > 0 else None\n            }\n        \n        # Cash Flow Summary (latest year)\n        if not cash_flow.empty:\n            latest_cash_flow = cash_flow.iloc[:, 0]\n            summary['cash_flow'] = {\n                'operating_cash_flow': latest_cash_flow.get('Operating Cash Flow', 0),\n                'investing_cash_flow': latest_cash_flow.get('Investing Cash Flow', 0),\n                'financing_cash_flow': latest_cash_flow.get('Financing Cash Flow', 0),\n                'free_cash_flow': latest_cash_flow.get('Free Cash Flow', 0),\n                'capital_expenditure': latest_cash_flow.get('Capital Expenditure', 0),\n                'year': cash_flow.columns[0].year if len(cash_flow.columns) > 0 else None\n            }\n        \n        # Calculate trends if multiple years available\n        if len(financials.columns) >= 2:\n            revenue_growth = ((financials.loc['Total Revenue'].iloc[0] - \n                             financials.loc['Total Revenue'].iloc[1]) / \n                            financials.loc['Total Revenue'].iloc[1]) * 100\n            \n            net_income_growth = ((financials.loc['Net Income'].iloc[0] - \n                                financials.loc['Net Income'].iloc[1]) / \n                               abs(financials.loc['Net Income'].iloc[1])) * 100\n            \n            summary['growth_trends'] = {\n                'revenue_growth_yoy': revenue_growth,\n                'net_income_growth_yoy': net_income_growth\n            }\n        \n        return summary\n        \n    except Exception as e:\n        print(f\"Error getting financial statements summary for {symbol}: {e}\")\n        return {}\n","size_bytes":19748},"utils/load_css.py":{"content":"import streamlit as st\nimport os\n\n\ndef load_css():\n    css_path = os.path.join(\"style\", \"style.css\")\n    with open(css_path) as f:\n        st.markdown(f\"<style>{f.read()}</style>\", unsafe_allow_html=True)\n","size_bytes":205},"utils/market_data.py":{"content":"import yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport requests\nimport json\nfrom typing import Tuple, Optional\n\ndef get_nifty_data(period: str = \"1mo\") -> pd.DataFrame:\n    \"\"\"\n    Fetch NIFTY 50 historical data\n    \"\"\"\n    try:\n        nifty = yf.Ticker(\"^NSEI\")\n        data = nifty.history(period=period)\n        return data\n    except Exception as e:\n        print(f\"Error fetching NIFTY data: {e}\")\n        return pd.DataFrame()\n\ndef get_stock_data(symbol: str, period: str = \"1mo\") -> pd.DataFrame:\n    \"\"\"\n    Fetch individual stock data with NSE suffix\n    \"\"\"\n    try:\n        # Add .NS suffix for NSE stocks if not present\n        if not symbol.endswith('.NS') and not symbol.startswith('^'):\n            symbol = f\"{symbol}.NS\"\n        \n        stock = yf.Ticker(symbol)\n        data = stock.history(period=period)\n        return data\n    except Exception as e:\n        print(f\"Error fetching stock data for {symbol}: {e}\")\n        return pd.DataFrame()\n\ndef get_multiple_stocks_data(symbols: list, period: str = \"1mo\") -> dict:\n    \"\"\"\n    Fetch data for multiple stocks\n    \"\"\"\n    stocks_data = {}\n    for symbol in symbols:\n        data = get_stock_data(symbol, period)\n        if not data.empty:\n            stocks_data[symbol] = data\n    return stocks_data\n\ndef get_top_gainers_losers() -> Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Get top gainers and losers from NSE\n    Note: This is a simplified version. In production, you'd use NSE API or scraping\n    \"\"\"\n    try:\n        # Sample NIFTY 50 stocks for demonstration\n        nifty_stocks = [\n            'RELIANCE.NS', 'TCS.NS', 'HDFCBANK.NS', 'INFY.NS', 'HINDUNILVR.NS',\n            'ICICIBANK.NS', 'KOTAKBANK.NS', 'SBIN.NS', 'BHARTIARTL.NS', 'ITC.NS',\n            'ASIANPAINT.NS', 'LT.NS', 'AXISBANK.NS', 'MARUTI.NS', 'SUNPHARMA.NS',\n            'TITAN.NS', 'ULTRACEMCO.NS', 'WIPRO.NS', 'NESTLEIND.NS', 'POWERGRID.NS'\n        ]\n        \n        gainers_data = []\n        losers_data = []\n        \n        for stock in nifty_stocks:\n            try:\n                ticker = yf.Ticker(stock)\n                hist = ticker.history(period=\"2d\")\n                \n                if len(hist) >= 2:\n                    current_price = hist['Close'].iloc[-1]\n                    prev_price = hist['Close'].iloc[-2]\n                    change = current_price - prev_price\n                    change_pct = (change / prev_price) * 100\n                    \n                    stock_data = {\n                        'Symbol': stock.replace('.NS', ''),\n                        'LTP': round(current_price, 2),\n                        'Change': round(change, 2),\n                        '% Change': round(change_pct, 2)\n                    }\n                    \n                    if change_pct > 0:\n                        gainers_data.append(stock_data)\n                    else:\n                        losers_data.append(stock_data)\n            except:\n                continue\n        \n        # Sort by percentage change\n        gainers_df = pd.DataFrame(gainers_data).sort_values('% Change', ascending=False)\n        losers_df = pd.DataFrame(losers_data).sort_values('% Change', ascending=True)\n        \n        return gainers_df, losers_df\n        \n    except Exception as e:\n        print(f\"Error fetching top movers: {e}\")\n        return pd.DataFrame(), pd.DataFrame()\n\ndef get_real_time_price(symbol: str) -> Optional[float]:\n    \"\"\"\n    Get real-time price for a stock\n    \"\"\"\n    try:\n        if not symbol.endswith('.NS') and not symbol.startswith('^'):\n            symbol = f\"{symbol}.NS\"\n            \n        ticker = yf.Ticker(symbol)\n        data = ticker.history(period=\"1d\", interval=\"1m\")\n        \n        if not data.empty:\n            return data['Close'].iloc[-1]\n        return None\n    except Exception as e:\n        print(f\"Error fetching real-time price for {symbol}: {e}\")\n        return None\n\ndef calculate_technical_indicators(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Calculate common technical indicators\n    \"\"\"\n    try:\n        df = data.copy()\n        \n        # Moving averages\n        df['SMA_20'] = df['Close'].rolling(window=20).mean()\n        df['SMA_50'] = df['Close'].rolling(window=50).mean()\n        df['EMA_12'] = df['Close'].ewm(span=12).mean()\n        df['EMA_26'] = df['Close'].ewm(span=26).mean()\n        \n        # MACD\n        df['MACD'] = df['EMA_12'] - df['EMA_26']\n        df['MACD_Signal'] = df['MACD'].ewm(span=9).mean()\n        \n        # RSI\n        delta = df['Close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n        rs = gain / loss\n        df['RSI'] = 100 - (100 / (1 + rs))\n        \n        # Bollinger Bands\n        df['BB_Middle'] = df['Close'].rolling(window=20).mean()\n        bb_std = df['Close'].rolling(window=20).std()\n        df['BB_Upper'] = df['BB_Middle'] + (bb_std * 2)\n        df['BB_Lower'] = df['BB_Middle'] - (bb_std * 2)\n        \n        return df\n        \n    except Exception as e:\n        print(f\"Error calculating technical indicators: {e}\")\n        return data\n\ndef detect_breakouts(symbol: str = None, days_range: int = 7):\n    \"\"\"\n    Detect if a stock is breaking out of its recent range\n    If no symbol provided, returns breakouts for multiple NIFTY stocks\n    \"\"\"\n    if symbol is None:\n        # Get breakouts for multiple NIFTY stocks\n        breakouts_list = get_nifty_breakouts(days_range)\n        return {'breakouts': breakouts_list}\n    \n    try:\n        data = get_stock_data(symbol, period=\"3mo\")\n        if data.empty:\n            return {}\n        \n        # Get recent range\n        recent_data = data.tail(days_range)\n        range_high = recent_data['High'].max()\n        range_low = recent_data['Low'].min()\n        current_price = data['Close'].iloc[-1]\n        \n        # Check for breakout\n        is_breakout = current_price > range_high\n        volume_spike = data['Volume'].iloc[-1] / data['Volume'].rolling(20).mean().iloc[-1]\n        \n        return {\n            'symbol': symbol,\n            'current_price': current_price,\n            'range_high': range_high,\n            'range_low': range_low,\n            'is_breakout': is_breakout,\n            'volume_spike': volume_spike,\n            'days_in_range': days_range\n        }\n        \n    except Exception as e:\n        print(f\"Error detecting breakout for {symbol}: {e}\")\n        return {}\n\ndef get_nifty_breakouts(days_range: int = 7):\n    \"\"\"\n    Get breakout analysis for multiple NIFTY 50 stocks\n    \"\"\"\n    nifty_stocks = [\n        'RELIANCE', 'TCS', 'INFY', 'HDFC', 'ICICIBANK', 'KOTAKBANK', 'HDFCBANK',\n        'ITC', 'LT', 'SBIN', 'BHARTIARTL', 'ASIANPAINT', 'MARUTI', 'NESTLEIND',\n        'ULTRACEMCO', 'AXISBANK', 'M&M', 'SUNPHARMA', 'TITAN', 'WIPRO'\n    ]\n    \n    breakouts = []\n    \n    for stock in nifty_stocks:\n        try:\n            data = get_stock_data(stock, period=\"2mo\")\n            if data.empty:\n                continue\n                \n            # Get recent range (6-8 days)\n            recent_data = data.tail(days_range)\n            range_high = recent_data['High'].max()\n            range_low = recent_data['Low'].min()\n            current_price = data['Close'].iloc[-1]\n            range_size = range_high - range_low\n            \n            # Check for breakout\n            is_breakout = current_price > range_high\n            volume_ratio = 1.0\n            \n            try:\n                volume_ratio = data['Volume'].iloc[-1] / data['Volume'].rolling(10).mean().iloc[-1]\n            except:\n                volume_ratio = 1.0\n            \n            # Calculate breakout strength\n            strength = 0\n            if is_breakout:\n                price_above_range = (current_price - range_high) / range_high * 100\n                strength = min(price_above_range * volume_ratio, 10)\n            \n            # Only include if it's a actual breakout or strong volume\n            if is_breakout or volume_ratio > 1.5:\n                breakouts.append({\n                    'symbol': stock,\n                    'current_price': current_price,\n                    'breakout_range': days_range,\n                    'strength': strength,\n                    'volume_ratio': volume_ratio,\n                    'is_breakout': is_breakout,\n                    'range_high': range_high,\n                    'range_low': range_low\n                })\n                \n        except Exception as e:\n            continue\n    \n    # Sort by strength and return top breakouts\n    breakouts.sort(key=lambda x: x['strength'], reverse=True)\n    return breakouts[:15]  # Return top 15\n\ndef get_market_status() -> dict:\n    \"\"\"\n    Get current market status (open/closed)\n    \"\"\"\n    try:\n        now = datetime.now()\n        \n        # NSE trading hours: 9:15 AM to 3:30 PM IST (Monday to Friday)\n        market_open_time = now.replace(hour=9, minute=15, second=0)\n        market_close_time = now.replace(hour=15, minute=30, second=0)\n        \n        is_weekday = now.weekday() < 5  # Monday is 0, Friday is 4\n        is_trading_hours = market_open_time <= now <= market_close_time\n        \n        market_open = is_weekday and is_trading_hours\n        \n        return {\n            'is_open': market_open,\n            'current_time': now.strftime('%Y-%m-%d %H:%M:%S'),\n            'next_open': 'Next trading day 9:15 AM' if not market_open else 'Market is open',\n            'market_session': 'Regular' if market_open else 'Closed'\n        }\n        \n    except Exception as e:\n        print(f\"Error getting market status: {e}\")\n        return {'is_open': False, 'error': str(e)}\n","size_bytes":9713},"utils/news_scraper.py":{"content":"import trafilatura\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nfrom datetime import datetime, timedelta\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\nimport streamlit as st\nimport json\nimport os\n\nclass NewsAggregator:\n    \"\"\"News aggregator for financial and market news\"\"\"\n    \n    def __init__(self):\n        self.news_sources = [\n            {\n                'name': 'Economic Times - Markets',\n                'url': 'https://economictimes.indiatimes.com/markets',\n                'xpath': '//article//h3//a',\n                'selector': 'article h3 a'\n            },\n            {\n                'name': 'Business Standard - Markets',\n                'url': 'https://www.business-standard.com/markets',\n                'xpath': '//div[@class=\"listing-content\"]//h2//a',\n                'selector': 'div.listing-content h2 a'\n            },\n            {\n                'name': 'MoneyControl',\n                'url': 'https://www.moneycontrol.com/news/business/markets/',\n                'xpath': '//div[@class=\"news_title\"]//a',\n                'selector': 'div.news_title a'\n            }\n        ]\n        self.cache_file = 'news_cache.json'\n        self.cache_duration = 3600  # 1 hour cache\n        \n    def get_cached_news(self):\n        \"\"\"Get news from cache if valid\"\"\"\n        try:\n            if os.path.exists(self.cache_file):\n                with open(self.cache_file, 'r', encoding='utf-8') as f:\n                    cache_data = json.load(f)\n                \n                cache_time = datetime.fromisoformat(cache_data.get('timestamp', ''))\n                if (datetime.now() - cache_time).seconds < self.cache_duration:\n                    return cache_data.get('articles', [])\n        except Exception:\n            pass\n        return None\n    \n    def save_news_cache(self, articles):\n        \"\"\"Save news to cache\"\"\"\n        try:\n            cache_data = {\n                'timestamp': datetime.now().isoformat(),\n                'articles': articles\n            }\n            with open(self.cache_file, 'w', encoding='utf-8') as f:\n                json.dump(cache_data, f, indent=2, ensure_ascii=False)\n        except Exception:\n            pass\n    \n    def scrape_news_from_source(self, source):\n        \"\"\"Scrape news from a specific source\"\"\"\n        articles = []\n        try:\n            headers = {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n            }\n            \n            response = requests.get(source['url'], headers=headers, timeout=10)\n            if response.status_code != 200:\n                return articles\n            \n            soup = BeautifulSoup(response.content, 'html.parser')\n            \n            # Try to find article links\n            links = []\n            if 'selector' in source:\n                elements = soup.select(source['selector'])\n                links = [elem.get('href') for elem in elements if elem.get('href')]\n            \n            # Clean and process links\n            for link in links[:5]:  # Get top 5 articles per source\n                try:\n                    if link and isinstance(link, str):\n                        if link.startswith('/'):\n                            # Relative URL\n                            base_url = source['url'].split('/')[0] + '//' + source['url'].split('/')[2]\n                            full_url = base_url + link\n                        elif link.startswith('http'):\n                            full_url = link\n                        else:\n                            continue\n                    else:\n                        continue\n                    \n                    # Get article title\n                    article_title = self.extract_title_from_url(full_url)\n                    if article_title:\n                        articles.append({\n                            'title': article_title,\n                            'url': full_url,\n                            'source': source['name'],\n                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M')\n                        })\n                        \n                except Exception:\n                    continue\n                    \n        except Exception:\n            pass\n        \n        return articles\n    \n    def extract_title_from_url(self, url):\n        \"\"\"Extract title from article URL\"\"\"\n        try:\n            headers = {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            }\n            \n            response = requests.get(url, headers=headers, timeout=5)\n            if response.status_code == 200:\n                # Use trafilatura to extract clean title\n                downloaded = trafilatura.fetch_url(url)\n                if downloaded:\n                    metadata = trafilatura.extract_metadata(downloaded)\n                    if metadata and metadata.title:\n                        return metadata.title[:100]  # Limit title length\n            \n            # Fallback: extract from URL\n            title_from_url = url.split('/')[-1].replace('-', ' ').replace('_', ' ')\n            title_from_url = re.sub(r'\\d+', '', title_from_url)  # Remove numbers\n            title_from_url = title_from_url.strip().title()\n            return title_from_url[:80] if len(title_from_url) > 10 else None\n            \n        except Exception:\n            return None\n    \n    def get_latest_news(self, max_articles=15):\n        \"\"\"Get latest financial news articles\"\"\"\n        # Check cache first\n        cached_articles = self.get_cached_news()\n        if cached_articles:\n            return cached_articles\n        \n        all_articles = []\n        \n        # Use ThreadPoolExecutor for parallel scraping\n        with ThreadPoolExecutor(max_workers=3) as executor:\n            futures = {executor.submit(self.scrape_news_from_source, source): source \n                      for source in self.news_sources}\n            \n            for future in futures:\n                try:\n                    articles = future.result(timeout=10)\n                    all_articles.extend(articles)\n                except Exception:\n                    continue\n        \n        # Remove duplicates and sort by timestamp\n        seen_titles = set()\n        unique_articles = []\n        \n        for article in all_articles:\n            title_lower = article['title'].lower()\n            if title_lower not in seen_titles and len(article['title']) > 20:\n                seen_titles.add(title_lower)\n                unique_articles.append(article)\n        \n        # Sort by timestamp and limit\n        unique_articles = sorted(unique_articles, \n                               key=lambda x: x['timestamp'], reverse=True)[:max_articles]\n        \n        # Cache the results\n        self.save_news_cache(unique_articles)\n        \n        return unique_articles\n    \n    def get_sample_news(self):\n        \"\"\"Get sample news when live scraping fails\"\"\"\n        return [\n            {\n                'title': 'NIFTY 50 Surges 250 Points on Strong FII Inflows and Banking Rally',\n                'url': '#',\n                'source': 'Market Today',\n                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Banking Stocks Outperform as NIM Expansion Continues in Q3 Results',\n                'url': '#',\n                'source': 'Banking Wire', \n                'timestamp': (datetime.now() - timedelta(hours=1)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Foreign Institutional Investors Turn Net Buyers After 3-Week Selling',\n                'url': '#',\n                'source': 'FII Watch',\n                'timestamp': (datetime.now() - timedelta(hours=2)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'IT Sector Outlook Brightens as US Client Spending Recovery Gains Momentum',\n                'url': '#',\n                'source': 'Tech Markets',\n                'timestamp': (datetime.now() - timedelta(hours=3)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'RBI Monetary Policy Committee Meeting: Rate Cut Expectations Build',\n                'url': '#',\n                'source': 'Policy Central',\n                'timestamp': (datetime.now() - timedelta(hours=4)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Pharma Stocks Rally on Strong Quarterly Earnings and US FDA Approvals',\n                'url': '#',\n                'source': 'Pharma Focus',\n                'timestamp': (datetime.now() - timedelta(hours=5)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Auto Sector Shows Green Shoots with Festive Season Demand Recovery',\n                'url': '#',\n                'source': 'Auto News',\n                'timestamp': (datetime.now() - timedelta(hours=6)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Oil & Gas Stocks Under Pressure as Crude Prices Decline Globally',\n                'url': '#',\n                'source': 'Energy Watch',\n                'timestamp': (datetime.now() - timedelta(hours=7)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'FMCG Giants Report Steady Growth Despite Rural Demand Challenges',\n                'url': '#',\n                'source': 'Consumer Goods',\n                'timestamp': (datetime.now() - timedelta(hours=8)).strftime('%Y-%m-%d %H:%M')\n            },\n            {\n                'title': 'Renewable Energy Stocks Soar on Government Policy Support',\n                'url': '#',\n                'source': 'Green Energy',\n                'timestamp': (datetime.now() - timedelta(hours=9)).strftime('%Y-%m-%d %H:%M')\n            }\n        ]\n\n# Global instance\nnews_aggregator = NewsAggregator()\n\ndef get_financial_news():\n    \"\"\"Main function to get financial news\"\"\"\n    try:\n        # For now, use sample news to ensure reliability\n        # TODO: Enable live scraping after testing\n        return news_aggregator.get_sample_news()\n    except Exception:\n        # Return sample news if scraping fails\n        return news_aggregator.get_sample_news()","size_bytes":10345},"utils/notifications.py":{"content":"import json\nimport os\nfrom datetime import datetime\nfrom typing import List, Optional, Dict\nimport logging\n\n# Free and open-source notification system\n# Uses file-based storage and web interface display instead of paid services\n\ndef save_report_notification(recipient: str, subject: str, body: str, report_type: str = \"daily\") -> bool:\n    \"\"\"\n    Save report notification to file system (free alternative to email)\n    Creates HTML and JSON files for easy viewing and data access\n    \"\"\"\n    try:\n        # Create reports directory if it doesn't exist\n        reports_dir = \"reports\"\n        if not os.path.exists(reports_dir):\n            os.makedirs(reports_dir)\n        \n        # Generate timestamp\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        date_str = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        # Save as HTML file for easy viewing\n        html_content = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>{subject}</title>\n            <style>\n                body {{ font-family: Arial, sans-serif; margin: 40px; }}\n                .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}\n                .content {{ margin: 20px 0; }}\n                .footer {{ color: #666; font-size: 12px; margin-top: 30px; }}\n            </style>\n        </head>\n        <body>\n            <div class=\"header\">\n                <h2>{subject}</h2>\n                <p><strong>Generated:</strong> {date_str}</p>\n                <p><strong>Recipient:</strong> {recipient}</p>\n            </div>\n            <div class=\"content\">\n                {body}\n            </div>\n            <div class=\"footer\">\n                <p>Generated by AI Trading Agent - Free & Open Source</p>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        # Save HTML file\n        html_filename = f\"{reports_dir}/{report_type}_report_{timestamp}.html\"\n        with open(html_filename, 'w', encoding='utf-8') as f:\n            f.write(html_content)\n        \n        # Save metadata as JSON\n        metadata = {\n            \"recipient\": recipient,\n            \"subject\": subject,\n            \"timestamp\": date_str,\n            \"report_type\": report_type,\n            \"html_file\": html_filename,\n            \"body_preview\": body[:200] + \"...\" if len(body) > 200 else body\n        }\n        \n        json_filename = f\"{reports_dir}/{report_type}_meta_{timestamp}.json\"\n        with open(json_filename, 'w', encoding='utf-8') as f:\n            json.dump(metadata, f, indent=2)\n        \n        logging.info(f\"Report saved successfully: {html_filename}\")\n        return True\n        \n    except Exception as e:\n        logging.error(f\"Failed to save report notification: {e}\")\n        return False\n\ndef save_notification_message(recipient_phone: str, message: str, message_type: str = \"alert\") -> bool:\n    \"\"\"\n    Save notification message to file system (free alternative to WhatsApp)\n    Creates a message log that can be accessed through the web interface\n    \"\"\"\n    try:\n        # Create notifications directory\n        notifications_dir = \"notifications\"\n        if not os.path.exists(notifications_dir):\n            os.makedirs(notifications_dir)\n        \n        # Generate timestamp\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        date_str = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        # Create notification data\n        notification = {\n            \"recipient\": recipient_phone,\n            \"message\": message,\n            \"message_type\": message_type,\n            \"timestamp\": date_str,\n            \"status\": \"saved\",\n            \"id\": timestamp\n        }\n        \n        # Save individual notification\n        filename = f\"{notifications_dir}/msg_{timestamp}.json\"\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(notification, f, indent=2)\n        \n        # Update notifications index\n        index_file = f\"{notifications_dir}/index.json\"\n        notifications_index = []\n        if os.path.exists(index_file):\n            try:\n                with open(index_file, 'r', encoding='utf-8') as f:\n                    notifications_index = json.load(f)\n            except:\n                notifications_index = []\n        \n        notifications_index.append(notification)\n        # Keep only last 100 notifications\n        notifications_index = notifications_index[-100:]\n        \n        with open(index_file, 'w', encoding='utf-8') as f:\n            json.dump(notifications_index, f, indent=2)\n        \n        logging.info(f\"Notification saved successfully: {filename}\")\n        return True\n        \n    except Exception as e:\n        logging.error(f\"Failed to save notification: {e}\")\n        return False\n\ndef format_daily_report_html(market_summary: str, top_gainers: List[dict], top_losers: List[dict], ai_insights: dict) -> str:\n    \"\"\"\n    Format daily market report as HTML for file storage\n    \"\"\"\n    html_template = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <style>\n            body {{ font-family: Arial, sans-serif; margin: 20px; }}\n            .header {{ background-color: #FF6B6B; color: white; padding: 20px; text-align: center; }}\n            .section {{ margin: 20px 0; padding: 15px; border-left: 4px solid #FF6B6B; }}\n            .metrics {{ display: flex; justify-content: space-around; margin: 20px 0; }}\n            .metric {{ text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 5px; }}\n            table {{ border-collapse: collapse; width: 100%; margin: 10px 0; }}\n            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}\n            th {{ background-color: #f2f2f2; }}\n            .positive {{ color: green; }}\n            .negative {{ color: red; }}\n            .footer {{ margin-top: 30px; padding: 15px; background-color: #f8f9fa; text-align: center; }}\n        </style>\n    </head>\n    <body>\n        <div class=\"header\">\n            <h1>AI Trading Agent - Daily Market Report</h1>\n            <p>Your personalized Indian market analysis</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>Market Summary</h2>\n            <p>{market_summary}</p>\n        </div>\n        \n        <div class=\"section\">\n            <h2>Top Gainers</h2>\n            <table>\n                <tr><th>Symbol</th><th>Price</th><th>Change</th><th>% Change</th></tr>\n    \"\"\"\n    \n    # Add top gainers\n    for gainer in top_gainers[:5]:\n        html_template += f\"\"\"\n                <tr>\n                    <td>{gainer.get('Symbol', 'N/A')}</td>\n                    <td>‚Çπ{gainer.get('LTP', 0):.2f}</td>\n                    <td class=\"positive\">+‚Çπ{gainer.get('Change', 0):.2f}</td>\n                    <td class=\"positive\">+{gainer.get('% Change', 0):.2f}%</td>\n                </tr>\n        \"\"\"\n    \n    html_template += \"\"\"\n            </table>\n        </div>\n        \n        <div class=\"section\">\n            <h2>Top Losers</h2>\n            <table>\n                <tr><th>Symbol</th><th>Price</th><th>Change</th><th>% Change</th></tr>\n    \"\"\"\n    \n    # Add top losers\n    for loser in top_losers[:5]:\n        html_template += f\"\"\"\n                <tr>\n                    <td>{loser.get('Symbol', 'N/A')}</td>\n                    <td>‚Çπ{loser.get('LTP', 0):.2f}</td>\n                    <td class=\"negative\">‚Çπ{loser.get('Change', 0):.2f}</td>\n                    <td class=\"negative\">{loser.get('% Change', 0):.2f}%</td>\n                </tr>\n        \"\"\"\n    \n    # Add AI insights if available\n    ai_section = \"\"\n    if ai_insights:\n        sentiment = ai_insights.get('sentiment', 'neutral').title()\n        probability = ai_insights.get('probability', 0) * 100\n        direction = ai_insights.get('direction', 'sideways').title()\n        \n        ai_section = f\"\"\"\n        <div class=\"section\">\n            <h2>AI Market Insights</h2>\n            <div class=\"metrics\">\n                <div class=\"metric\">\n                    <h3>Market Sentiment</h3>\n                    <p><strong>{sentiment}</strong></p>\n                </div>\n                <div class=\"metric\">\n                    <h3>Probability Score</h3>\n                    <p><strong>{probability:.1f}%</strong></p>\n                </div>\n                <div class=\"metric\">\n                    <h3>Expected Direction</h3>\n                    <p><strong>{direction}</strong></p>\n                </div>\n            </div>\n            <p>{ai_insights.get('analysis', 'AI analysis not available')}</p>\n        </div>\n        \"\"\"\n    \n    html_template += ai_section\n    \n    html_template += \"\"\"\n        <div class=\"footer\">\n            <p><strong>AI Trading Agent</strong> | Automated Market Intelligence</p>\n            <p>This report was generated automatically. Please do your own research before making investment decisions.</p>\n        </div>\n    </body>\n    </html>\n    \"\"\"\n    \n    return html_template\n\ndef format_notification_message(market_summary: str, nifty_change: float, top_gainer: str, top_loser: str) -> str:\n    \"\"\"\n    Format notification message for file storage\n    \"\"\"\n    emoji = \"üìà\" if nifty_change >= 0 else \"üìâ\"\n    direction = \"up\" if nifty_change >= 0 else \"down\"\n    \n    message = f\"\"\"AI Trading Agent - Morning Brief\n\n{emoji} Market Update\nNIFTY 50: {direction} {abs(nifty_change):.2f}%\n\nüìà Top Gainer: {top_gainer}\nüìâ Top Loser: {top_loser}\n\nAI Insight: {market_summary[:100]}...\n\nHave a great trading day!\nGenerated by AI Trading Agent\"\"\"\n    \n    return message\n\ndef send_daily_notifications(recipient_email: str, recipient_phone: str, market_data: dict) -> dict:\n    \"\"\"\n    Save both report and notification messages (free alternative to email/WhatsApp)\n    \"\"\"\n    results = {'email': False, 'whatsapp': False}\n    \n    try:\n        # Extract data\n        market_summary = market_data.get('summary', 'Market data unavailable')\n        top_gainers = market_data.get('gainers', [])\n        top_losers = market_data.get('losers', [])\n        ai_insights = market_data.get('ai_insights', {})\n        nifty_change = market_data.get('nifty_change', 0)\n        \n        # Save email report\n        email_body = format_daily_report_html(market_summary, top_gainers, top_losers, ai_insights)\n        email_subject = f\"Daily Market Report - {market_data.get('date', 'Today')}\"\n        \n        results['email'] = save_report_notification(recipient_email, email_subject, email_body, \"daily\")\n        \n        # Save notification message\n        top_gainer_name = top_gainers[0]['Symbol'] if top_gainers else 'N/A'\n        top_loser_name = top_losers[0]['Symbol'] if top_losers else 'N/A'\n        \n        notification_message = format_notification_message(\n            market_summary, nifty_change, top_gainer_name, top_loser_name\n        )\n        \n        results['whatsapp'] = save_notification_message(recipient_phone, notification_message, \"daily\")\n        \n    except Exception as e:\n        logging.error(f\"Error sending daily notifications: {e}\")\n    \n    return results\n\ndef send_alert_notification(recipient_email: str, recipient_phone: str, alert_type: str, message: str) -> dict:\n    \"\"\"\n    Save alert notifications for urgent market events (free alternative to email/WhatsApp)\n    \"\"\"\n    results = {'email': False, 'whatsapp': False}\n    \n    try:\n        # Save alert report\n        email_subject = f\"{alert_type} Alert - AI Trading Agent\"\n        email_body = f\"\"\"\n        <html>\n        <body style=\"font-family: Arial, sans-serif;\">\n            <div style=\"background-color: #FF6B6B; color: white; padding: 20px; text-align: center;\">\n                <h1>Market Alert</h1>\n            </div>\n            <div style=\"padding: 20px;\">\n                <h2>{alert_type}</h2>\n                <p>{message}</p>\n                <p><em>Alert generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} IST</em></p>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        results['email'] = save_report_notification(recipient_email, email_subject, email_body, \"alert\")\n        \n        # Save notification message\n        notification_alert = f\"{alert_type} Alert\\n\\n{message}\\n\\nAI Trading Agent\"\n        results['whatsapp'] = save_notification_message(recipient_phone, notification_alert, \"alert\")\n        \n    except Exception as e:\n        logging.error(f\"Error sending alert notification: {e}\")\n    \n    return results\n\ndef get_saved_notifications(limit: int = 20) -> List[Dict]:\n    \"\"\"\n    Retrieve saved notifications from file system\n    \"\"\"\n    try:\n        notifications_dir = \"notifications\"\n        index_file = f\"{notifications_dir}/index.json\"\n        \n        if not os.path.exists(index_file):\n            return []\n        \n        with open(index_file, 'r', encoding='utf-8') as f:\n            notifications = json.load(f)\n        \n        # Return most recent notifications\n        return notifications[-limit:] if notifications else []\n        \n    except Exception as e:\n        logging.error(f\"Error retrieving notifications: {e}\")\n        return []\n\ndef get_saved_reports(limit: int = 10) -> List[Dict]:\n    \"\"\"\n    Retrieve saved reports from file system\n    \"\"\"\n    try:\n        reports_dir = \"reports\"\n        if not os.path.exists(reports_dir):\n            return []\n        \n        reports = []\n        for filename in os.listdir(reports_dir):\n            if filename.endswith('_meta.json'):\n                try:\n                    with open(f\"{reports_dir}/{filename}\", 'r', encoding='utf-8') as f:\n                        report_meta = json.load(f)\n                        reports.append(report_meta)\n                except Exception as e:\n                    logging.error(f\"Error reading report {filename}: {e}\")\n        \n        # Sort by timestamp (newest first)\n        reports.sort(key=lambda x: x.get('timestamp', ''), reverse=True)\n        return reports[:limit]\n        \n    except Exception as e:\n        logging.error(f\"Error retrieving reports: {e}\")\n        return []\n\ndef save_alert_notification(recipient: str, subject: str, message: str, alert_type: str = \"alert\") -> bool:\n    \"\"\"\n    Save alert notification to file system\n    \"\"\"\n    return save_notification_message(recipient, f\"{subject}: {message}\", alert_type)\n\ndef test_notification_setup() -> dict:\n    \"\"\"\n    Test notification setup and return status (for free system)\n    \"\"\"\n    test_results = {\n        'reports_directory': False,\n        'notifications_directory': False,\n        'write_permissions': False,\n        'system_status': 'Free notification system active'\n    }\n    \n    try:\n        # Test reports directory\n        reports_dir = \"reports\"\n        if not os.path.exists(reports_dir):\n            os.makedirs(reports_dir)\n        test_results['reports_directory'] = os.path.exists(reports_dir)\n        \n        # Test notifications directory\n        notifications_dir = \"notifications\"\n        if not os.path.exists(notifications_dir):\n            os.makedirs(notifications_dir)\n        test_results['notifications_directory'] = os.path.exists(notifications_dir)\n        \n        # Test write permissions\n        test_file = f\"{reports_dir}/test.txt\"\n        with open(test_file, 'w') as f:\n            f.write(\"test\")\n        if os.path.exists(test_file):\n            os.remove(test_file)\n            test_results['write_permissions'] = True\n        \n    except Exception as e:\n        logging.error(f\"Notification setup test failed: {e}\")\n    \n    return test_results","size_bytes":15490},"utils/portfolio.py":{"content":"import pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Optional, Tuple\nfrom datetime import datetime, timedelta\nimport json\nimport os\nfrom .market_data import get_stock_data, get_real_time_price\nfrom .fundamentals import get_fundamental_data\nfrom .ai_analysis import analyze_portfolio_risk\n\nclass Portfolio:\n    def __init__(self, portfolio_file: str = \"portfolio.json\"):\n        self.portfolio_file = portfolio_file\n        self.holdings = self._load_portfolio()\n        self.watchlist = self._load_watchlist()\n    \n    def _load_portfolio(self) -> List[Dict]:\n        \"\"\"Load portfolio from JSON file\"\"\"\n        try:\n            if os.path.exists(self.portfolio_file):\n                with open(self.portfolio_file, 'r') as f:\n                    data = json.load(f)\n                    return data.get('holdings', [])\n            return []\n        except Exception as e:\n            print(f\"Error loading portfolio: {e}\")\n            return []\n    \n    def _load_watchlist(self) -> List[str]:\n        \"\"\"Load watchlist from JSON file\"\"\"\n        try:\n            if os.path.exists(self.portfolio_file):\n                with open(self.portfolio_file, 'r') as f:\n                    data = json.load(f)\n                    return data.get('watchlist', [])\n            return []\n        except Exception as e:\n            print(f\"Error loading watchlist: {e}\")\n            return []\n    \n    def _save_portfolio(self):\n        \"\"\"Save portfolio and watchlist to JSON file\"\"\"\n        try:\n            data = {\n                'holdings': self.holdings,\n                'watchlist': self.watchlist,\n                'last_updated': datetime.now().isoformat()\n            }\n            with open(self.portfolio_file, 'w') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e:\n            print(f\"Error saving portfolio: {e}\")\n    \n    def add_holding(self, symbol: str, quantity: int, buy_price: float, buy_date: str = None) -> bool:\n        \"\"\"Add a new holding to portfolio\"\"\"\n        try:\n            if buy_date is None:\n                buy_date = datetime.now().strftime('%Y-%m-%d')\n            \n            # Check if holding already exists\n            for holding in self.holdings:\n                if holding['symbol'] == symbol:\n                    # Update existing holding (average cost)\n                    total_cost = (holding['quantity'] * holding['buy_price']) + (quantity * buy_price)\n                    total_quantity = holding['quantity'] + quantity\n                    holding['buy_price'] = total_cost / total_quantity\n                    holding['quantity'] = total_quantity\n                    holding['last_updated'] = datetime.now().isoformat()\n                    self._save_portfolio()\n                    return True\n            \n            # Add new holding\n            new_holding = {\n                'symbol': symbol,\n                'quantity': quantity,\n                'buy_price': buy_price,\n                'buy_date': buy_date,\n                'added_date': datetime.now().isoformat(),\n                'last_updated': datetime.now().isoformat()\n            }\n            \n            self.holdings.append(new_holding)\n            self._save_portfolio()\n            return True\n            \n        except Exception as e:\n            print(f\"Error adding holding: {e}\")\n            return False\n    \n    def remove_holding(self, symbol: str, quantity: int = None) -> bool:\n        \"\"\"Remove holding or reduce quantity\"\"\"\n        try:\n            for i, holding in enumerate(self.holdings):\n                if holding['symbol'] == symbol:\n                    if quantity is None or quantity >= holding['quantity']:\n                        # Remove entire holding\n                        self.holdings.pop(i)\n                    else:\n                        # Reduce quantity\n                        holding['quantity'] -= quantity\n                        holding['last_updated'] = datetime.now().isoformat()\n                    \n                    self._save_portfolio()\n                    return True\n            \n            return False\n            \n        except Exception as e:\n            print(f\"Error removing holding: {e}\")\n            return False\n    \n    def add_to_watchlist(self, symbol: str) -> bool:\n        \"\"\"Add stock to watchlist\"\"\"\n        try:\n            if symbol not in self.watchlist:\n                self.watchlist.append(symbol)\n                self._save_portfolio()\n                return True\n            return False\n        except Exception as e:\n            print(f\"Error adding to watchlist: {e}\")\n            return False\n    \n    def remove_from_watchlist(self, symbol: str) -> bool:\n        \"\"\"Remove stock from watchlist\"\"\"\n        try:\n            if symbol in self.watchlist:\n                self.watchlist.remove(symbol)\n                self._save_portfolio()\n                return True\n            return False\n        except Exception as e:\n            print(f\"Error removing from watchlist: {e}\")\n            return False\n    \n    def get_portfolio_summary(self) -> Dict:\n        \"\"\"Get comprehensive portfolio summary\"\"\"\n        try:\n            if not self.holdings:\n                return {\n                    'total_value': 0,\n                    'total_invested': 0,\n                    'total_pnl': 0,\n                    'total_pnl_percent': 0,\n                    'holdings_count': 0,\n                    'top_performer': None,\n                    'worst_performer': None\n                }\n            \n            total_value = 0\n            total_invested = 0\n            holdings_performance = []\n            \n            for holding in self.holdings:\n                symbol = holding['symbol']\n                quantity = holding['quantity']\n                buy_price = holding['buy_price']\n                \n                # Get current price\n                current_price = get_real_time_price(symbol)\n                if current_price is None:\n                    current_price = buy_price  # Fallback to buy price\n                \n                # Calculate metrics\n                invested_amount = quantity * buy_price\n                current_value = quantity * current_price\n                pnl = current_value - invested_amount\n                pnl_percent = (pnl / invested_amount) * 100 if invested_amount > 0 else 0\n                \n                total_value += current_value\n                total_invested += invested_amount\n                \n                holdings_performance.append({\n                    'symbol': symbol,\n                    'quantity': quantity,\n                    'buy_price': buy_price,\n                    'current_price': current_price,\n                    'invested_amount': invested_amount,\n                    'current_value': current_value,\n                    'pnl': pnl,\n                    'pnl_percent': pnl_percent\n                })\n            \n            total_pnl = total_value - total_invested\n            total_pnl_percent = (total_pnl / total_invested) * 100 if total_invested > 0 else 0\n            \n            # Find top and worst performers\n            if holdings_performance:\n                top_performer = max(holdings_performance, key=lambda x: x['pnl_percent'])\n                worst_performer = min(holdings_performance, key=lambda x: x['pnl_percent'])\n            else:\n                top_performer = worst_performer = None\n            \n            return {\n                'total_value': total_value,\n                'total_invested': total_invested,\n                'total_pnl': total_pnl,\n                'total_pnl_percent': total_pnl_percent,\n                'holdings_count': len(self.holdings),\n                'holdings_performance': holdings_performance,\n                'top_performer': top_performer,\n                'worst_performer': worst_performer\n            }\n            \n        except Exception as e:\n            print(f\"Error getting portfolio summary: {e}\")\n            return {}\n    \n    def get_sector_allocation(self) -> Dict:\n        \"\"\"Get portfolio allocation by sector\"\"\"\n        try:\n            if not self.holdings:\n                return {}\n            \n            sector_allocation = {}\n            total_value = 0\n            \n            for holding in self.holdings:\n                symbol = holding['symbol']\n                quantity = holding['quantity']\n                current_price = get_real_time_price(symbol) or holding['buy_price']\n                holding_value = quantity * current_price\n                \n                # Get sector information\n                fundamental_data = get_fundamental_data(symbol)\n                sector = fundamental_data.get('basic_info', {}).get('sector', 'Unknown')\n                \n                if sector not in sector_allocation:\n                    sector_allocation[sector] = {\n                        'value': 0,\n                        'stocks': [],\n                        'percentage': 0\n                    }\n                \n                sector_allocation[sector]['value'] += holding_value\n                sector_allocation[sector]['stocks'].append(symbol)\n                total_value += holding_value\n            \n            # Calculate percentages\n            for sector in sector_allocation:\n                sector_allocation[sector]['percentage'] = (\n                    sector_allocation[sector]['value'] / total_value * 100\n                ) if total_value > 0 else 0\n            \n            return sector_allocation\n            \n        except Exception as e:\n            print(f\"Error getting sector allocation: {e}\")\n            return {}\n    \n    def get_portfolio_performance_history(self, period: str = \"1mo\") -> Dict:\n        \"\"\"Get historical performance of portfolio\"\"\"\n        try:\n            if not self.holdings:\n                return {}\n            \n            # Get historical data for all holdings\n            portfolio_history = {}\n            \n            for holding in self.holdings:\n                symbol = holding['symbol']\n                quantity = holding['quantity']\n                \n                # Get historical data\n                stock_data = get_stock_data(symbol, period)\n                \n                if not stock_data.empty:\n                    # Calculate holding value over time\n                    holding_values = stock_data['Close'] * quantity\n                    portfolio_history[symbol] = holding_values\n            \n            if not portfolio_history:\n                return {}\n            \n            # Combine all holdings into portfolio timeline\n            portfolio_df = pd.DataFrame(portfolio_history)\n            portfolio_total = portfolio_df.sum(axis=1)\n            \n            # Calculate returns\n            portfolio_returns = portfolio_total.pct_change().dropna()\n            \n            # Performance metrics\n            total_return = (portfolio_total.iloc[-1] / portfolio_total.iloc[0] - 1) * 100\n            volatility = portfolio_returns.std() * np.sqrt(252) * 100  # Annualized\n            sharpe_ratio = (portfolio_returns.mean() / portfolio_returns.std() * np.sqrt(252)) if portfolio_returns.std() > 0 else 0\n            max_drawdown = ((portfolio_total / portfolio_total.expanding().max()) - 1).min() * 100\n            \n            return {\n                'total_return': total_return,\n                'volatility': volatility,\n                'sharpe_ratio': sharpe_ratio,\n                'max_drawdown': max_drawdown,\n                'portfolio_timeline': portfolio_total.to_dict(),\n                'daily_returns': portfolio_returns.to_dict()\n            }\n            \n        except Exception as e:\n            print(f\"Error getting portfolio performance history: {e}\")\n            return {}\n    \n    def get_watchlist_data(self) -> List[Dict]:\n        \"\"\"Get current data for watchlist stocks\"\"\"\n        try:\n            watchlist_data = []\n            \n            for symbol in self.watchlist:\n                current_price = get_real_time_price(symbol)\n                if current_price:\n                    # Get basic stock data\n                    stock_data = get_stock_data(symbol, period=\"5d\")\n                    \n                    if not stock_data.empty:\n                        prev_price = stock_data['Close'].iloc[-2] if len(stock_data) > 1 else current_price\n                        change = current_price - prev_price\n                        change_percent = (change / prev_price) * 100 if prev_price > 0 else 0\n                        \n                        # Get fundamental data\n                        fundamental = get_fundamental_data(symbol)\n                        basic_info = fundamental.get('basic_info', {})\n                        \n                        watchlist_data.append({\n                            'symbol': symbol,\n                            'company_name': basic_info.get('company_name', 'N/A'),\n                            'current_price': current_price,\n                            'change': change,\n                            'change_percent': change_percent,\n                            'sector': basic_info.get('sector', 'N/A'),\n                            'market_cap': basic_info.get('market_cap', 0)\n                        })\n            \n            return watchlist_data\n            \n        except Exception as e:\n            print(f\"Error getting watchlist data: {e}\")\n            return []\n    \n    def calculate_portfolio_risk(self) -> Dict:\n        \"\"\"Calculate portfolio risk metrics\"\"\"\n        try:\n            if not self.holdings:\n                return {}\n            \n            # Prepare portfolio data for AI analysis\n            portfolio_for_analysis = []\n            \n            for holding in self.holdings:\n                symbol = holding['symbol']\n                quantity = holding['quantity']\n                current_price = get_real_time_price(symbol) or holding['buy_price']\n                \n                portfolio_for_analysis.append({\n                    'symbol': symbol,\n                    'quantity': quantity,\n                    'current_price': current_price\n                })\n            \n            # Get AI-powered risk analysis\n            ai_risk_analysis = analyze_portfolio_risk(portfolio_for_analysis)\n            \n            # Calculate additional risk metrics\n            portfolio_summary = self.get_portfolio_summary()\n            sector_allocation = self.get_sector_allocation()\n            \n            # Concentration risk (top 3 holdings percentage)\n            holdings_by_value = sorted(\n                portfolio_summary.get('holdings_performance', []),\n                key=lambda x: x['current_value'],\n                reverse=True\n            )\n            \n            top_3_percentage = 0\n            total_value = portfolio_summary.get('total_value', 0)\n            \n            for i in range(min(3, len(holdings_by_value))):\n                top_3_percentage += (holdings_by_value[i]['current_value'] / total_value * 100) if total_value > 0 else 0\n            \n            # Sector concentration risk\n            max_sector_allocation = max(\n                [sector['percentage'] for sector in sector_allocation.values()]\n            ) if sector_allocation else 0\n            \n            risk_metrics = {\n                'concentration_risk': {\n                    'top_3_holdings_percentage': top_3_percentage,\n                    'max_sector_allocation': max_sector_allocation,\n                    'number_of_holdings': len(self.holdings),\n                    'number_of_sectors': len(sector_allocation)\n                },\n                'diversification_score': min(100, (len(self.holdings) * 10) + (len(sector_allocation) * 5)),\n                'ai_analysis': ai_risk_analysis\n            }\n            \n            return risk_metrics\n            \n        except Exception as e:\n            print(f\"Error calculating portfolio risk: {e}\")\n            return {}\n    \n    def get_portfolio_recommendations(self) -> Dict:\n        \"\"\"Get AI-powered portfolio recommendations\"\"\"\n        try:\n            if not self.holdings:\n                return {'message': 'No holdings in portfolio for analysis'}\n            \n            # Get current portfolio analysis\n            portfolio_summary = self.get_portfolio_summary()\n            sector_allocation = self.get_sector_allocation()\n            risk_metrics = self.calculate_portfolio_risk()\n            \n            recommendations = {\n                'rebalancing': [],\n                'additions': [],\n                'reductions': [],\n                'risk_mitigation': []\n            }\n            \n            # Rebalancing recommendations\n            if sector_allocation:\n                for sector, allocation in sector_allocation.items():\n                    if allocation['percentage'] > 40:\n                        recommendations['rebalancing'].append({\n                            'type': 'Reduce sector concentration',\n                            'description': f\"Consider reducing {sector} allocation from {allocation['percentage']:.1f}%\",\n                            'priority': 'High' if allocation['percentage'] > 50 else 'Medium'\n                        })\n            \n            # Performance-based recommendations\n            holdings_performance = portfolio_summary.get('holdings_performance', [])\n            \n            for holding in holdings_performance:\n                if holding['pnl_percent'] < -20:\n                    recommendations['reductions'].append({\n                        'symbol': holding['symbol'],\n                        'description': f\"Consider reviewing {holding['symbol']} (down {abs(holding['pnl_percent']):.1f}%)\",\n                        'current_loss': holding['pnl_percent']\n                    })\n            \n            # Diversification recommendations\n            if len(self.holdings) < 5:\n                recommendations['additions'].append({\n                    'type': 'Increase diversification',\n                    'description': 'Consider adding more stocks to reduce concentration risk',\n                    'priority': 'Medium'\n                })\n            \n            # Risk mitigation from AI analysis\n            ai_analysis = risk_metrics.get('ai_analysis', {})\n            if ai_analysis and 'recommendations' in ai_analysis:\n                recommendations['risk_mitigation'] = ai_analysis['recommendations']\n            \n            return recommendations\n            \n        except Exception as e:\n            print(f\"Error getting portfolio recommendations: {e}\")\n            return {}\n    \n    def export_portfolio_data(self) -> Dict:\n        \"\"\"Export complete portfolio data\"\"\"\n        try:\n            return {\n                'portfolio_summary': self.get_portfolio_summary(),\n                'sector_allocation': self.get_sector_allocation(),\n                'performance_history': self.get_portfolio_performance_history(),\n                'watchlist': self.get_watchlist_data(),\n                'risk_analysis': self.calculate_portfolio_risk(),\n                'recommendations': self.get_portfolio_recommendations(),\n                'export_date': datetime.now().isoformat()\n            }\n        except Exception as e:\n            print(f\"Error exporting portfolio data: {e}\")\n            return {}\n","size_bytes":19366},"utils/scheduler.py":{"content":"import schedule\nimport time\nimport threading\nfrom datetime import datetime, timedelta\nimport logging\nfrom typing import Callable, Dict, List\nimport os\nfrom .market_data import get_nifty_data, get_top_gainers_losers, get_market_status\nfrom .ai_analysis import generate_daily_market_summary, get_market_sentiment_analysis\nfrom .notifications import send_daily_notifications\nfrom .portfolio import Portfolio\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('scheduler.log'),\n        logging.StreamHandler()\n    ]\n)\n\nclass TradingScheduler:\n    def __init__(self):\n        self.running = False\n        self.scheduler_thread = None\n        self.portfolio = Portfolio()\n        \n        # Configuration from environment variables\n        self.notification_email = os.environ.get(\"NOTIFICATION_EMAIL\", \"user@example.com\")\n        self.notification_phone = os.environ.get(\"NOTIFICATION_PHONE\", \"+919999999999\")\n        \n        # Market timing (IST)\n        self.market_open_time = \"09:15\"\n        self.market_close_time = \"15:30\"\n        self.daily_report_time = \"08:00\"  # Before market opens\n        \n        # Setup scheduled jobs\n        self._setup_scheduled_jobs()\n    \n    def _setup_scheduled_jobs(self):\n        \"\"\"Setup all scheduled jobs\"\"\"\n        try:\n            # Daily morning report\n            schedule.every().day.at(self.daily_report_time).do(self._send_daily_report)\n            \n            # Market opening alert\n            schedule.every().monday.at(self.market_open_time).do(self._market_opening_alert)\n            schedule.every().tuesday.at(self.market_open_time).do(self._market_opening_alert)\n            schedule.every().wednesday.at(self.market_open_time).do(self._market_opening_alert)\n            schedule.every().thursday.at(self.market_open_time).do(self._market_opening_alert)\n            schedule.every().friday.at(self.market_open_time).do(self._market_opening_alert)\n            \n            # Market closing summary\n            schedule.every().monday.at(self.market_close_time).do(self._market_closing_summary)\n            schedule.every().tuesday.at(self.market_close_time).do(self._market_closing_summary)\n            schedule.every().wednesday.at(self.market_close_time).do(self._market_closing_summary)\n            schedule.every().thursday.at(self.market_close_time).do(self._market_closing_summary)\n            schedule.every().friday.at(self.market_close_time).do(self._market_closing_summary)\n            \n            # Portfolio review (weekly)\n            schedule.every().friday.at(\"17:00\").do(self._weekly_portfolio_review)\n            \n            # Hourly market monitoring during trading hours\n            for hour in range(9, 16):  # 9 AM to 3 PM\n                for minute in [0, 30]:  # Every 30 minutes\n                    time_str = f\"{hour:02d}:{minute:02d}\"\n                    schedule.every().monday.at(time_str).do(self._hourly_market_check)\n                    schedule.every().tuesday.at(time_str).do(self._hourly_market_check)\n                    schedule.every().wednesday.at(time_str).do(self._hourly_market_check)\n                    schedule.every().thursday.at(time_str).do(self._hourly_market_check)\n                    schedule.every().friday.at(time_str).do(self._hourly_market_check)\n            \n            logging.info(\"Scheduled jobs setup completed\")\n            \n        except Exception as e:\n            logging.error(f\"Error setting up scheduled jobs: {e}\")\n    \n    def _send_daily_report(self):\n        \"\"\"Generate and send daily market report\"\"\"\n        try:\n            logging.info(\"Generating daily market report...\")\n            \n            # Generate market summary using AI\n            market_summary = generate_daily_market_summary()\n            \n            # Get market data\n            gainers, losers = get_top_gainers_losers()\n            \n            # Get AI insights\n            ai_insights = get_market_sentiment_analysis()\n            \n            # Get NIFTY change\n            nifty_data = get_nifty_data(period=\"2d\")\n            nifty_change = 0\n            if not nifty_data.empty and len(nifty_data) >= 2:\n                current = nifty_data['Close'].iloc[-1]\n                previous = nifty_data['Close'].iloc[-2]\n                nifty_change = ((current - previous) / previous) * 100\n            \n            # Prepare market data for notifications\n            market_data = {\n                'summary': market_summary or \"Market analysis not available\",\n                'gainers': gainers.to_dict('records') if not gainers.empty else [],\n                'losers': losers.to_dict('records') if not losers.empty else [],\n                'ai_insights': ai_insights or {},\n                'nifty_change': nifty_change,\n                'date': datetime.now().strftime('%Y-%m-%d')\n            }\n            \n            # Send notifications\n            notification_results = send_daily_notifications(\n                self.notification_email,\n                self.notification_phone,\n                market_data\n            )\n            \n            logging.info(f\"Daily report sent - Email: {notification_results['email']}, WhatsApp: {notification_results['whatsapp']}\")\n            \n        except Exception as e:\n            logging.error(f\"Error sending daily report: {e}\")\n    \n    def _market_opening_alert(self):\n        \"\"\"Send market opening alert\"\"\"\n        try:\n            market_status = get_market_status()\n            \n            if market_status.get('is_open', False):\n                message = \"üöÄ Market is now OPEN! Good luck with your trades today.\"\n                \n                # Send quick alert\n                from .notifications import send_whatsapp_message\n                send_whatsapp_message(self.notification_phone, message)\n                \n                logging.info(\"Market opening alert sent\")\n        \n        except Exception as e:\n            logging.error(f\"Error sending market opening alert: {e}\")\n    \n    def _market_closing_summary(self):\n        \"\"\"Send market closing summary\"\"\"\n        try:\n            # Get end-of-day data\n            nifty_data = get_nifty_data(period=\"1d\")\n            gainers, losers = get_top_gainers_losers()\n            \n            if not nifty_data.empty:\n                current_price = nifty_data['Close'].iloc[-1]\n                # Get previous day's close for comparison\n                prev_data = get_nifty_data(period=\"2d\")\n                if len(prev_data) >= 2:\n                    prev_price = prev_data['Close'].iloc[-2]\n                    change = current_price - prev_price\n                    change_pct = (change / prev_price) * 100\n                else:\n                    change_pct = 0\n                \n                direction = \"üìà\" if change_pct >= 0 else \"üìâ\"\n                \n                message = f\"\"\"üîî Market CLOSED\n                \n{direction} NIFTY 50: {current_price:.2f} ({change_pct:+.2f}%)\n\nüìä Top Performer: {gainers.iloc[0]['Symbol'] if not gainers.empty else 'N/A'}\nüìä Worst Performer: {losers.iloc[0]['Symbol'] if not losers.empty else 'N/A'}\n\nSee you tomorrow! üåô\"\"\"\n                \n                from .notifications import send_whatsapp_message\n                send_whatsapp_message(self.notification_phone, message)\n                \n                logging.info(\"Market closing summary sent\")\n        \n        except Exception as e:\n            logging.error(f\"Error sending market closing summary: {e}\")\n    \n    def _hourly_market_check(self):\n        \"\"\"Hourly market monitoring during trading hours\"\"\"\n        try:\n            market_status = get_market_status()\n            \n            if not market_status.get('is_open', False):\n                return\n            \n            # Check for significant market movements\n            nifty_data = get_nifty_data(period=\"1d\")\n            \n            if not nifty_data.empty and len(nifty_data) >= 2:\n                current_price = nifty_data['Close'].iloc[-1]\n                hour_ago_price = nifty_data['Close'].iloc[-2] if len(nifty_data) >= 2 else current_price\n                \n                hourly_change = ((current_price - hour_ago_price) / hour_ago_price) * 100\n                \n                # Alert for significant movements (>1% in an hour)\n                if abs(hourly_change) > 1.0:\n                    direction = \"üìà SURGE\" if hourly_change > 0 else \"üìâ FALL\"\n                    \n                    message = f\"\"\"üö® MARKET ALERT\n                    \n{direction}: NIFTY moved {hourly_change:+.2f}% in the last hour!\n\nCurrent: {current_price:.2f}\nTime: {datetime.now().strftime('%H:%M')}\n\nStay alert! üëÄ\"\"\"\n                    \n                    from .notifications import send_whatsapp_message\n                    send_whatsapp_message(self.notification_phone, message)\n                    \n                    logging.info(f\"Significant market movement alert sent: {hourly_change:.2f}%\")\n        \n        except Exception as e:\n            logging.error(f\"Error in hourly market check: {e}\")\n    \n    def _weekly_portfolio_review(self):\n        \"\"\"Weekly portfolio performance review\"\"\"\n        try:\n            portfolio_summary = self.portfolio.get_portfolio_summary()\n            \n            if portfolio_summary.get('holdings_count', 0) == 0:\n                return\n            \n            total_pnl_pct = portfolio_summary.get('total_pnl_percent', 0)\n            top_performer = portfolio_summary.get('top_performer', {})\n            worst_performer = portfolio_summary.get('worst_performer', {})\n            \n            performance_emoji = \"üü¢\" if total_pnl_pct >= 0 else \"üî¥\"\n            \n            message = f\"\"\"üìä WEEKLY PORTFOLIO REVIEW\n            \n{performance_emoji} Overall P&L: {total_pnl_pct:+.2f}%\nüí∞ Portfolio Value: ‚Çπ{portfolio_summary.get('total_value', 0):,.2f}\n\nüèÜ Best: {top_performer.get('symbol', 'N/A')} ({top_performer.get('pnl_percent', 0):+.1f}%)\nüìâ Worst: {worst_performer.get('symbol', 'N/A')} ({worst_performer.get('pnl_percent', 0):+.1f}%)\n\nReview your strategy! üí°\"\"\"\n            \n            from .notifications import send_whatsapp_message\n            send_whatsapp_message(self.notification_phone, message)\n            \n            # Also send detailed email report\n            portfolio_data = self.portfolio.export_portfolio_data()\n            from .notifications import send_email_report\n            \n            email_subject = f\"Weekly Portfolio Review - {datetime.now().strftime('%Y-%m-%d')}\"\n            email_body = f\"\"\"\n            <h2>Weekly Portfolio Performance Report</h2>\n            <p>Overall P&L: {total_pnl_pct:+.2f}%</p>\n            <p>Portfolio Value: ‚Çπ{portfolio_summary.get('total_value', 0):,.2f}</p>\n            <p>Holdings Count: {portfolio_summary.get('holdings_count', 0)}</p>\n            \"\"\"\n            \n            send_email_report(self.notification_email, email_subject, email_body)\n            \n            logging.info(\"Weekly portfolio review sent\")\n        \n        except Exception as e:\n            logging.error(f\"Error in weekly portfolio review: {e}\")\n    \n    def start_scheduler(self):\n        \"\"\"Start the scheduler in a separate thread\"\"\"\n        if self.running:\n            logging.warning(\"Scheduler is already running\")\n            return\n        \n        self.running = True\n        \n        def run_scheduler():\n            logging.info(\"Scheduler started\")\n            while self.running:\n                try:\n                    schedule.run_pending()\n                    time.sleep(60)  # Check every minute\n                except Exception as e:\n                    logging.error(f\"Error in scheduler loop: {e}\")\n                    time.sleep(60)\n        \n        self.scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)\n        self.scheduler_thread.start()\n        \n        logging.info(\"Scheduler thread started\")\n    \n    def stop_scheduler(self):\n        \"\"\"Stop the scheduler\"\"\"\n        if not self.running:\n            logging.warning(\"Scheduler is not running\")\n            return\n        \n        self.running = False\n        if self.scheduler_thread:\n            self.scheduler_thread.join(timeout=5)\n        \n        logging.info(\"Scheduler stopped\")\n    \n    def get_scheduled_jobs(self) -> List[Dict]:\n        \"\"\"Get list of scheduled jobs\"\"\"\n        jobs = []\n        for job in schedule.jobs:\n            jobs.append({\n                'job_func': job.job_func.__name__,\n                'interval': str(job.interval),\n                'unit': job.unit,\n                'at_time': str(job.at_time) if job.at_time else None,\n                'next_run': str(job.next_run) if job.next_run else None\n            })\n        return jobs\n    \n    def add_custom_alert(self, symbol: str, condition: str, value: float, alert_type: str = \"price\"):\n        \"\"\"Add custom price or percentage alerts\"\"\"\n        try:\n            # This would be implemented to add custom alerts\n            # For now, just log the request\n            logging.info(f\"Custom alert requested: {symbol} {condition} {value} ({alert_type})\")\n            \n            # In a full implementation, this would:\n            # 1. Store the alert in a database or file\n            # 2. Add a scheduled job to check the condition\n            # 3. Send notification when condition is met\n            \n        except Exception as e:\n            logging.error(f\"Error adding custom alert: {e}\")\n    \n    def test_notifications(self) -> Dict:\n        \"\"\"Test notification system\"\"\"\n        try:\n            from .notifications import test_notification_setup\n            \n            test_results = test_notification_setup()\n            \n            # Send test messages if configuration is working\n            if test_results['email_config'] and test_results['smtp_connection']:\n                from .notifications import send_email_report\n                send_email_report(\n                    self.notification_email,\n                    \"üß™ Test Email - AI Trading Agent\",\n                    \"<h2>Email notifications are working!</h2><p>Your daily reports will be delivered here.</p>\"\n                )\n            \n            if test_results['twilio_config'] and test_results['twilio_connection']:\n                from .notifications import send_whatsapp_message\n                send_whatsapp_message(\n                    self.notification_phone,\n                    \"üß™ Test message from AI Trading Agent! WhatsApp notifications are working perfectly. üöÄ\"\n                )\n            \n            logging.info(f\"Notification test completed: {test_results}\")\n            return test_results\n            \n        except Exception as e:\n            logging.error(f\"Error testing notifications: {e}\")\n            return {'error': str(e)}\n\n# Global scheduler instance\ntrading_scheduler = TradingScheduler()\n\ndef get_scheduler_instance():\n    \"\"\"Get the global scheduler instance\"\"\"\n    return trading_scheduler\n","size_bytes":15071},"utils/screener.py":{"content":"import yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List, Optional, Tuple\nfrom datetime import datetime, timedelta\nimport concurrent.futures\nfrom .fundamentals import get_fundamental_data, calculate_financial_score\nfrom .market_data import calculate_technical_indicators, get_stock_data\n\n# Common Indian stock universe\nINDIAN_STOCKS = [\n    'RELIANCE', 'TCS', 'HDFCBANK', 'INFY', 'HINDUNILVR', 'ICICIBANK', 'KOTAKBANK',\n    'SBIN', 'BHARTIARTL', 'ITC', 'ASIANPAINT', 'LT', 'AXISBANK', 'MARUTI', 'SUNPHARMA',\n    'TITAN', 'ULTRACEMCO', 'WIPRO', 'NESTLEIND', 'POWERGRID', 'TATAMOTORS', 'ONGC',\n    'NTPC', 'TECHM', 'HCLTECH', 'DIVISLAB', 'CIPLA', 'DRREDDY', 'BAJFINANCE',\n    'BAJAJFINSV', 'COALINDIA', 'IOC', 'GRASIM', 'JSWSTEEL', 'HINDALCO', 'INDUSINDBK',\n    'ADANIPORTS', 'BRITANNIA', 'EICHERMOT', 'HEROMOTOCO', 'SHREECEM', 'BAJAJ-AUTO',\n    'TATASTEEL', 'BPCL', 'APOLLOHOSP', 'HDFCLIFE', 'SBILIFE', 'ICICIPRULI',\n    'PIDILITIND', 'GODREJCP', 'MARICO', 'DABUR'\n]\n\nclass StockScreener:\n    def __init__(self):\n        self.stock_universe = INDIAN_STOCKS\n        self.cache = {}\n        self.cache_expiry = timedelta(hours=1)\n        \n    def _get_stock_data_cached(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Get stock data with caching\"\"\"\n        cache_key = f\"{symbol}_data\"\n        current_time = datetime.now()\n        \n        # Check if data is in cache and not expired\n        if cache_key in self.cache:\n            cached_data, timestamp = self.cache[cache_key]\n            if current_time - timestamp < self.cache_expiry:\n                return cached_data\n        \n        # Fetch fresh data\n        try:\n            fundamental_data = get_fundamental_data(symbol)\n            price_data = get_stock_data(symbol, period=\"3mo\")\n            \n            if fundamental_data and not price_data.empty:\n                # Add technical indicators\n                technical_data = calculate_technical_indicators(price_data)\n                \n                combined_data = {\n                    'symbol': symbol,\n                    'fundamental': fundamental_data,\n                    'technical': technical_data,\n                    'current_price': technical_data['Close'].iloc[-1] if not technical_data.empty else 0\n                }\n                \n                # Cache the data\n                self.cache[cache_key] = (combined_data, current_time)\n                return combined_data\n        except Exception as e:\n            print(f\"Error fetching data for {symbol}: {e}\")\n        \n        return None\n    \n    def rsi_screen(self, criteria: Dict) -> List[Dict]:\n        \"\"\"Screen stocks based on RSI criteria\"\"\"\n        try:\n            screened_stocks = []\n            \n            # RSI criteria\n            rsi_low = criteria.get('rsi_low', 30)\n            rsi_high = criteria.get('rsi_high', 70)\n            rsi_condition = criteria.get('rsi_condition', 'oversold')  # oversold, overbought, or range\n            \n            for symbol in self.stock_universe:\n                stock_data = self._get_stock_data_cached(symbol)\n                if not stock_data:\n                    continue\n                \n                technical_data = stock_data.get('technical', pd.DataFrame())\n                if technical_data.empty or 'RSI' not in technical_data.columns:\n                    continue\n                \n                current_rsi = technical_data['RSI'].iloc[-1]\n                current_price = technical_data['Close'].iloc[-1]\n                \n                # Check RSI condition\n                match_condition = False\n                if rsi_condition == 'oversold' and current_rsi <= rsi_low:\n                    match_condition = True\n                elif rsi_condition == 'overbought' and current_rsi >= rsi_high:\n                    match_condition = True\n                elif rsi_condition == 'range' and rsi_low <= current_rsi <= rsi_high:\n                    match_condition = True\n                \n                if match_condition:\n                    screened_stocks.append({\n                        'symbol': symbol,\n                        'current_price': current_price,\n                        'rsi': round(current_rsi, 2),\n                        'signal': rsi_condition,\n                        'score': 100 - abs(current_rsi - 50)  # Higher score for extreme values\n                    })\n            \n            # Sort by RSI value based on condition\n            if rsi_condition == 'oversold':\n                screened_stocks.sort(key=lambda x: x['rsi'])\n            elif rsi_condition == 'overbought':\n                screened_stocks.sort(key=lambda x: x['rsi'], reverse=True)\n            else:\n                screened_stocks.sort(key=lambda x: x['score'], reverse=True)\n            \n            return screened_stocks[:20]  # Return top 20 matches\n            \n        except Exception as e:\n            print(f\"Error in RSI screening: {e}\")\n            return []\n    \n    def supertrend_screen(self, criteria: Dict) -> List[Dict]:\n        \"\"\"Screen stocks based on Supertrend indicator\"\"\"\n        try:\n            screened_stocks = []\n            \n            # Supertrend criteria\n            signal_type = criteria.get('signal_type', 'buy')  # buy, sell\n            \n            for symbol in self.stock_universe:\n                stock_data = self._get_stock_data_cached(symbol)\n                if not stock_data:\n                    continue\n                \n                technical_data = stock_data.get('technical', pd.DataFrame())\n                if technical_data.empty:\n                    continue\n                \n                # Calculate Supertrend\n                supertrend_data = self._calculate_supertrend(technical_data)\n                if supertrend_data.empty:\n                    continue\n                \n                current_price = technical_data['Close'].iloc[-1]\n                current_supertrend = supertrend_data['Supertrend'].iloc[-1]\n                current_signal = supertrend_data['Signal'].iloc[-1]\n                \n                # Check signal condition\n                match_condition = False\n                if signal_type == 'buy' and current_signal == 'Buy':\n                    match_condition = True\n                elif signal_type == 'sell' and current_signal == 'Sell':\n                    match_condition = True\n                \n                if match_condition:\n                    # Calculate strength based on price distance from supertrend\n                    distance_pct = abs((current_price - current_supertrend) / current_supertrend) * 100\n                    \n                    screened_stocks.append({\n                        'symbol': symbol,\n                        'current_price': current_price,\n                        'supertrend': round(current_supertrend, 2),\n                        'signal': current_signal,\n                        'distance_pct': round(distance_pct, 2),\n                        'score': 100 - distance_pct  # Higher score for closer to supertrend\n                    })\n            \n            # Sort by score (best signals first)\n            screened_stocks.sort(key=lambda x: x['score'], reverse=True)\n            return screened_stocks[:15]\n            \n        except Exception as e:\n            print(f\"Error in Supertrend screening: {e}\")\n            return []\n    \n    def quarterly_earnings_screen(self, criteria: Dict) -> List[Dict]:\n        \"\"\"Screen stocks based on quarterly earnings performance\"\"\"\n        try:\n            screened_stocks = []\n            \n            # Earnings criteria\n            min_growth = criteria.get('min_growth', 10)  # Minimum earnings growth %\n            min_revenue_growth = criteria.get('min_revenue_growth', 5)\n            max_pe = criteria.get('max_pe', 25)\n            \n            for symbol in self.stock_universe:\n                stock_data = self._get_stock_data_cached(symbol)\n                if not stock_data:\n                    continue\n                \n                fundamental_data = stock_data.get('fundamental', {})\n                if not fundamental_data:\n                    continue\n                \n                current_price = stock_data.get('current_price', 0)\n                \n                # Extract key metrics (simplified)\n                pe_ratio = fundamental_data.get('pe_ratio', 0)\n                profit_growth = fundamental_data.get('profit_growth', 0)\n                revenue_growth = fundamental_data.get('revenue_growth', 0)\n                roe = fundamental_data.get('roe', 0)\n                \n                # Apply filters\n                if (pe_ratio > 0 and pe_ratio <= max_pe and \n                    profit_growth >= min_growth and \n                    revenue_growth >= min_revenue_growth):\n                    \n                    # Calculate composite score\n                    growth_score = (profit_growth + revenue_growth) / 2\n                    efficiency_score = min(roe / 15 * 25, 25)  # ROE normalized to 25 points\n                    valuation_score = max(0, 25 - (pe_ratio / max_pe * 25))  # Lower PE = higher score\n                    \n                    total_score = growth_score + efficiency_score + valuation_score\n                    \n                    screened_stocks.append({\n                        'symbol': symbol,\n                        'current_price': current_price,\n                        'pe_ratio': round(pe_ratio, 2),\n                        'profit_growth': round(profit_growth, 1),\n                        'revenue_growth': round(revenue_growth, 1),\n                        'roe': round(roe, 1),\n                        'score': round(total_score, 1)\n                    })\n            \n            # Sort by total score\n            screened_stocks.sort(key=lambda x: x['score'], reverse=True)\n            return screened_stocks[:20]\n            \n        except Exception as e:\n            print(f\"Error in quarterly earnings screening: {e}\")\n            return []\n    \n    def _calculate_supertrend(self, data: pd.DataFrame, period: int = 10, multiplier: float = 3.0) -> pd.DataFrame:\n        \"\"\"Calculate Supertrend indicator\"\"\"\n        try:\n            if data.empty or len(data) < period:\n                return pd.DataFrame()\n            \n            # Calculate ATR (Average True Range)\n            high = data['High']\n            low = data['Low']\n            close = data['Close']\n            \n            tr1 = high - low\n            tr2 = abs(high - close.shift(1))\n            tr3 = abs(low - close.shift(1))\n            \n            tr = pd.DataFrame({'tr1': tr1, 'tr2': tr2, 'tr3': tr3}).max(axis=1)\n            atr = tr.rolling(window=period).mean()\n            \n            # Calculate basic upper and lower bands\n            hl_avg = (high + low) / 2\n            upper_band = hl_avg + (multiplier * atr)\n            lower_band = hl_avg - (multiplier * atr)\n            \n            # Calculate final upper and lower bands\n            final_upper = upper_band.copy()\n            final_lower = lower_band.copy()\n            \n            for i in range(1, len(data)):\n                if upper_band.iloc[i] < final_upper.iloc[i-1] or close.iloc[i-1] > final_upper.iloc[i-1]:\n                    final_upper.iloc[i] = upper_band.iloc[i]\n                else:\n                    final_upper.iloc[i] = final_upper.iloc[i-1]\n                \n                if lower_band.iloc[i] > final_lower.iloc[i-1] or close.iloc[i-1] < final_lower.iloc[i-1]:\n                    final_lower.iloc[i] = lower_band.iloc[i]\n                else:\n                    final_lower.iloc[i] = final_lower.iloc[i-1]\n            \n            # Determine Supertrend and signals\n            supertrend = pd.Series(index=data.index, dtype=float)\n            signal = pd.Series(index=data.index, dtype=str)\n            \n            # Initial values\n            supertrend.iloc[0] = final_lower.iloc[0] if close.iloc[0] > final_upper.iloc[0] else final_upper.iloc[0]\n            signal.iloc[0] = 'Buy' if close.iloc[0] > final_upper.iloc[0] else 'Sell'\n            \n            for i in range(1, len(data)):\n                if close.iloc[i] > final_upper.iloc[i]:\n                    supertrend.iloc[i] = final_lower.iloc[i]\n                    signal.iloc[i] = 'Buy'\n                elif close.iloc[i] < final_lower.iloc[i]:\n                    supertrend.iloc[i] = final_upper.iloc[i]\n                    signal.iloc[i] = 'Sell'\n                else:\n                    supertrend.iloc[i] = supertrend.iloc[i-1]\n                    signal.iloc[i] = signal.iloc[i-1]\n            \n            result = pd.DataFrame({\n                'Supertrend': supertrend,\n                'Signal': signal,\n                'Upper_Band': final_upper,\n                'Lower_Band': final_lower\n            }, index=data.index)\n            \n            return result\n            \n        except Exception as e:\n            print(f\"Error calculating Supertrend: {e}\")\n            return pd.DataFrame()\n    \n    def fundamental_screen(self, criteria: Dict) -> List[Dict]:\n        \"\"\"Screen stocks based on fundamental criteria\"\"\"\n        try:\n            screened_stocks = []\n            \n            # Default criteria\n            default_criteria = {\n                'min_market_cap': 0,\n                'max_market_cap': float('inf'),\n                'min_pe_ratio': 0,\n                'max_pe_ratio': 50,\n                'min_roe': 0,\n                'max_debt_to_equity': 2.0,\n                'min_profit_margin': 0,\n                'min_revenue_growth': -0.5,\n                'dividend_yield': False,\n                'sectors': None  # List of sectors or None for all\n            }\n            \n            # Update with user criteria\n            screen_criteria = {**default_criteria, **criteria}\n            \n            # Screen stocks\n            for symbol in self.stock_universe:\n                stock_data = self._get_stock_data_cached(symbol)\n                \n                if not stock_data:\n                    continue\n                \n                fundamental = stock_data['fundamental']\n                \n                # Extract values for screening\n                basic_info = fundamental.get('basic_info', {})\n                valuation = fundamental.get('valuation_ratios', {})\n                profitability = fundamental.get('profitability_ratios', {})\n                financial_health = fundamental.get('financial_health', {})\n                growth = fundamental.get('growth_metrics', {})\n                dividend = fundamental.get('dividend_info', {})\n                \n                # Market cap filter\n                market_cap = basic_info.get('market_cap', 0)\n                if not (screen_criteria['min_market_cap'] <= market_cap <= screen_criteria['max_market_cap']):\n                    continue\n                \n                # PE ratio filter\n                pe_ratio = valuation.get('pe_ratio')\n                if pe_ratio and not (screen_criteria['min_pe_ratio'] <= pe_ratio <= screen_criteria['max_pe_ratio']):\n                    continue\n                \n                # ROE filter\n                roe = profitability.get('roe')\n                if roe and roe < screen_criteria['min_roe']:\n                    continue\n                \n                # Debt to equity filter\n                debt_to_equity = financial_health.get('debt_to_equity')\n                if debt_to_equity and debt_to_equity > screen_criteria['max_debt_to_equity']:\n                    continue\n                \n                # Profit margin filter\n                profit_margin = profitability.get('profit_margin')\n                if profit_margin and profit_margin < screen_criteria['min_profit_margin']:\n                    continue\n                \n                # Revenue growth filter\n                revenue_growth = growth.get('revenue_growth')\n                if revenue_growth and revenue_growth < screen_criteria['min_revenue_growth']:\n                    continue\n                \n                # Dividend yield filter\n                if screen_criteria['dividend_yield']:\n                    div_yield = dividend.get('dividend_yield', 0)\n                    if not div_yield or div_yield <= 0:\n                        continue\n                \n                # Sector filter\n                if screen_criteria['sectors']:\n                    sector = basic_info.get('sector', '')\n                    if sector not in screen_criteria['sectors']:\n                        continue\n                \n                # Calculate financial score\n                financial_score = calculate_financial_score(fundamental)\n                \n                # Add to results\n                screened_stocks.append({\n                    'symbol': symbol,\n                    'company_name': basic_info.get('company_name', 'N/A'),\n                    'sector': basic_info.get('sector', 'N/A'),\n                    'current_price': stock_data['current_price'],\n                    'market_cap': market_cap,\n                    'pe_ratio': pe_ratio,\n                    'roe': roe,\n                    'debt_to_equity': debt_to_equity,\n                    'profit_margin': profit_margin,\n                    'revenue_growth': revenue_growth,\n                    'dividend_yield': dividend.get('dividend_yield'),\n                    'financial_score': financial_score.get('percentage', 0),\n                    'financial_rating': financial_score.get('rating', 'N/A')\n                })\n            \n            # Sort by financial score\n            screened_stocks.sort(key=lambda x: x['financial_score'], reverse=True)\n            return screened_stocks\n            \n        except Exception as e:\n            print(f\"Error in fundamental screening: {e}\")\n            return []\n    \n    def technical_screen(self, criteria: Dict) -> List[Dict]:\n        \"\"\"Screen stocks based on technical criteria\"\"\"\n        try:\n            screened_stocks = []\n            \n            # Default technical criteria\n            default_criteria = {\n                'rsi_min': 30,\n                'rsi_max': 70,\n                'price_above_sma20': False,\n                'price_above_sma50': False,\n                'macd_bullish': False,\n                'volume_spike': False,\n                'breakout_pattern': False,\n                'min_volume': 0\n            }\n            \n            screen_criteria = {**default_criteria, **criteria}\n            \n            for symbol in self.stock_universe:\n                stock_data = self._get_stock_data_cached(symbol)\n                \n                if not stock_data:\n                    continue\n                \n                technical = stock_data['technical']\n                \n                if technical.empty:\n                    continue\n                \n                # Get latest values\n                current_price = technical['Close'].iloc[-1]\n                rsi = technical['RSI'].iloc[-1] if 'RSI' in technical.columns else None\n                sma20 = technical['SMA_20'].iloc[-1] if 'SMA_20' in technical.columns else None\n                sma50 = technical['SMA_50'].iloc[-1] if 'SMA_50' in technical.columns else None\n                macd = technical['MACD'].iloc[-1] if 'MACD' in technical.columns else None\n                macd_signal = technical['MACD_Signal'].iloc[-1] if 'MACD_Signal' in technical.columns else None\n                volume = technical['Volume'].iloc[-1]\n                avg_volume = technical['Volume'].rolling(20).mean().iloc[-1]\n                \n                # RSI filter\n                if rsi and not (screen_criteria['rsi_min'] <= rsi <= screen_criteria['rsi_max']):\n                    continue\n                \n                # Price above SMA filters\n                if screen_criteria['price_above_sma20'] and sma20 and current_price <= sma20:\n                    continue\n                \n                if screen_criteria['price_above_sma50'] and sma50 and current_price <= sma50:\n                    continue\n                \n                # MACD bullish filter\n                if screen_criteria['macd_bullish'] and macd and macd_signal:\n                    if macd <= macd_signal:\n                        continue\n                \n                # Volume spike filter\n                if screen_criteria['volume_spike'] and avg_volume:\n                    volume_ratio = volume / avg_volume\n                    if volume_ratio < 1.5:  # At least 1.5x average volume\n                        continue\n                \n                # Minimum volume filter\n                if volume < screen_criteria['min_volume']:\n                    continue\n                \n                # Breakout pattern detection\n                breakout_score = 0\n                if screen_criteria['breakout_pattern']:\n                    # Simple breakout detection\n                    high_20 = technical['High'].rolling(20).max().iloc[-2]  # Previous 20 days high\n                    if current_price > high_20:\n                        breakout_score = 1\n                    else:\n                        continue\n                \n                # Calculate technical score\n                technical_score = 0\n                total_indicators = 0\n                \n                if rsi:\n                    if 40 <= rsi <= 60:\n                        technical_score += 20\n                    elif 30 <= rsi <= 70:\n                        technical_score += 15\n                    total_indicators += 20\n                \n                if sma20 and current_price > sma20:\n                    technical_score += 15\n                total_indicators += 15\n                \n                if sma50 and current_price > sma50:\n                    technical_score += 15\n                total_indicators += 15\n                \n                if macd and macd_signal and macd > macd_signal:\n                    technical_score += 20\n                total_indicators += 20\n                \n                if avg_volume and volume / avg_volume > 1.2:\n                    technical_score += 10\n                total_indicators += 10\n                \n                technical_score_pct = (technical_score / total_indicators * 100) if total_indicators > 0 else 0\n                \n                screened_stocks.append({\n                    'symbol': symbol,\n                    'current_price': current_price,\n                    'rsi': rsi,\n                    'price_vs_sma20': ((current_price - sma20) / sma20 * 100) if sma20 else None,\n                    'price_vs_sma50': ((current_price - sma50) / sma50 * 100) if sma50 else None,\n                    'macd_signal': 'Bullish' if macd and macd_signal and macd > macd_signal else 'Bearish',\n                    'volume_ratio': volume / avg_volume if avg_volume else 1,\n                    'breakout_score': breakout_score,\n                    'technical_score': technical_score_pct\n                })\n            \n            # Sort by technical score\n            screened_stocks.sort(key=lambda x: x['technical_score'], reverse=True)\n            return screened_stocks\n            \n        except Exception as e:\n            print(f\"Error in technical screening: {e}\")\n            return []\n    \n    def combined_screen(self, fundamental_criteria: Dict, technical_criteria: Dict, weights: Dict = None) -> List[Dict]:\n        \"\"\"Combine fundamental and technical screening with weights\"\"\"\n        try:\n            if weights is None:\n                weights = {'fundamental': 0.6, 'technical': 0.4}\n            \n            # Get both screens\n            fundamental_results = self.fundamental_screen(fundamental_criteria)\n            technical_results = self.technical_screen(technical_criteria)\n            \n            # Create lookup for technical scores\n            technical_lookup = {result['symbol']: result for result in technical_results}\n            \n            combined_results = []\n            \n            for fund_result in fundamental_results:\n                symbol = fund_result['symbol']\n                tech_result = technical_lookup.get(symbol, {})\n                \n                # Calculate combined score\n                fund_score = fund_result.get('financial_score', 0)\n                tech_score = tech_result.get('technical_score', 0)\n                \n                combined_score = (fund_score * weights['fundamental'] + \n                                tech_score * weights['technical'])\n                \n                # Combine data\n                combined_data = {**fund_result, **tech_result}\n                combined_data['combined_score'] = combined_score\n                \n                combined_results.append(combined_data)\n            \n            # Sort by combined score\n            combined_results.sort(key=lambda x: x['combined_score'], reverse=True)\n            return combined_results\n            \n        except Exception as e:\n            print(f\"Error in combined screening: {e}\")\n            return []\n    \n    def momentum_screen(self) -> List[Dict]:\n        \"\"\"Screen for momentum stocks\"\"\"\n        momentum_criteria = {\n            'price_above_sma20': True,\n            'price_above_sma50': True,\n            'volume_spike': True,\n            'rsi_min': 50,\n            'rsi_max': 80,\n            'macd_bullish': True\n        }\n        \n        return self.technical_screen(momentum_criteria)\n    \n    def value_screen(self) -> List[Dict]:\n        \"\"\"Screen for value stocks\"\"\"\n        value_criteria = {\n            'max_pe_ratio': 20,\n            'min_roe': 0.12,\n            'max_debt_to_equity': 1.0,\n            'min_profit_margin': 0.05,\n            'dividend_yield': True\n        }\n        \n        return self.fundamental_screen(value_criteria)\n    \n    def growth_screen(self) -> List[Dict]:\n        \"\"\"Screen for growth stocks\"\"\"\n        growth_criteria = {\n            'min_revenue_growth': 0.15,\n            'min_roe': 0.15,\n            'min_profit_margin': 0.10,\n            'max_pe_ratio': 40\n        }\n        \n        return self.fundamental_screen(growth_criteria)\n    \n    def dividend_screen(self) -> List[Dict]:\n        \"\"\"Screen for dividend-paying stocks\"\"\"\n        dividend_criteria = {\n            'dividend_yield': True,\n            'min_roe': 0.10,\n            'max_debt_to_equity': 1.5,\n            'min_profit_margin': 0.05\n        }\n        \n        results = self.fundamental_screen(dividend_criteria)\n        \n        # Sort by dividend yield\n        results.sort(key=lambda x: x.get('dividend_yield', 0), reverse=True)\n        return results\n    \n    def quality_screen(self) -> List[Dict]:\n        \"\"\"Screen for quality stocks\"\"\"\n        quality_criteria = {\n            'min_roe': 0.15,\n            'min_profit_margin': 0.10,\n            'max_debt_to_equity': 0.5,\n            'min_revenue_growth': 0.05\n        }\n        \n        return self.fundamental_screen(quality_criteria)\n    \n    def get_sector_leaders(self, sector: str) -> List[Dict]:\n        \"\"\"Get leading stocks in a specific sector\"\"\"\n        sector_criteria = {\n            'sectors': [sector],\n            'min_market_cap': 1000000000,  # 1 billion minimum\n            'min_roe': 0.10\n        }\n        \n        results = self.fundamental_screen(sector_criteria)\n        \n        # Sort by market cap (largest first)\n        results.sort(key=lambda x: x.get('market_cap', 0), reverse=True)\n        return results[:10]  # Top 10 in sector\n    \n    def custom_screen(self, user_criteria: Dict) -> List[Dict]:\n        \"\"\"Allow users to create custom screens\"\"\"\n        try:\n            # Separate fundamental and technical criteria\n            fundamental_keys = [\n                'min_market_cap', 'max_market_cap', 'min_pe_ratio', 'max_pe_ratio',\n                'min_roe', 'max_debt_to_equity', 'min_profit_margin', 'min_revenue_growth',\n                'dividend_yield', 'sectors'\n            ]\n            \n            technical_keys = [\n                'rsi_min', 'rsi_max', 'price_above_sma20', 'price_above_sma50',\n                'macd_bullish', 'volume_spike', 'breakout_pattern', 'min_volume'\n            ]\n            \n            fundamental_criteria = {k: v for k, v in user_criteria.items() if k in fundamental_keys}\n            technical_criteria = {k: v for k, v in user_criteria.items() if k in technical_keys}\n            \n            # If both types of criteria, use combined screen\n            if fundamental_criteria and technical_criteria:\n                weights = user_criteria.get('weights', {'fundamental': 0.6, 'technical': 0.4})\n                return self.combined_screen(fundamental_criteria, technical_criteria, weights)\n            elif fundamental_criteria:\n                return self.fundamental_screen(fundamental_criteria)\n            elif technical_criteria:\n                return self.technical_screen(technical_criteria)\n            else:\n                # Return top stocks by financial score if no criteria\n                return self.fundamental_screen({})[:20]\n            \n        except Exception as e:\n            print(f\"Error in custom screening: {e}\")\n            return []\n","size_bytes":29143}},"version":1}